(function(){"use strict";angular.module("atsPadApp",["ngCookies","ngResource","ngSanitize","ngRoute"]).config(["$routeProvider",function(a){return a.when("/about",{templateUrl:"views/about.html"}).when("/help",{templateUrl:"views/help.html"}).when("/:id?",{templateUrl:"views/main.html",controller:"MainCtrl"}).when("/:id/fork",{templateUrl:"views/main.html",controller:"ForkCtrl"}).otherwise({redirectTo:"/"})}])}).call(this),function(){"use strict";angular.module("atsPadApp").controller("MainCtrl",["$cookies","$scope","$location","$timeout","$routeParams","appNotificationService","appPadService","appContextService","appEditorService","testPad","appTerminalService",function(a,b,c,d,e,f,g,h){var i,j;return j=f,i=function(){var a;return a=function(a){return g.validate(a)&&h.isReady()?(j.debug("saving"),g.syncToServer(a)):j.debug("not valid or ready, cancel saving")},b.$watch("pad",a,!0)},null==e.id?(j.debug("no pad id present, creating"),h.reset(),g.create(function(a){return d(function(){return c.path(a)})})):(j.debug("pad id "+e.id+", loading"),h.reset(),g.show(e.id,function(a){return b.pad=a,h.setId(a.id),h.ready()})),i()}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appPadService",["$http","appUrlService","appNotificationService","appContextService",function(a,b,c,d){var e,f,g;return f=c,g=function(a){var b,c,d,e,f,g,h;for(c={},h=a.filenames,e=function(b){return c[b]=a.filecontents[d]},d=f=0,g=h.length;g>f;d=++f)b=h[d],e(b);return{id:a.id,files:c}},e=function(a){var b,c,d,e,f,g;c=[],d=[],g=a.files,f=function(a,b){return c.push(b),d.push(a)};for(e in g)b=g[e],f(e,b);return{id:a.id,filecontents:c,filenames:d}},{create:function(c){var d,e;return f.debug("creating new pad"),d=b.create(),e=a.get(d),e.success(function(a){return f.debug("created: "+a),c(a)}),e.error(function(a){return f.error("failed to create pad",a)})},show:function(c,g){var h,i;return f.debug("loading pad "+c),d.setId(c),h=b.show(),i=a.get(h),i.success(function(a){return f.debug("loaded: "+c),g(e(a))}),i.error(function(a){return f.error("failed to load pad: "+c,a)})},syncToServer:function(c){var d,e,h;return f.debug("syncing to server: "+c.id),d=b.syncToServer(),e=angular.toJson(g(c)),h=a.post(d,e),h.success(function(){return f.success("saved")}),h.error(function(a){return f.error("failed to save changes: "+c.id,a)})},syncToClient:function(c){var d,g;return f.debug("syncing from server"),d=b.syncToClient(),g=a.get(d),g.success(function(a){return f.success("refreshed"),c(e(a))}),g.error(function(a){return f.error("failed to refresh",a)})},fork:function(c,e){var g,h;return f.debug("forking "+c),d.setId(c),g=b.forkApi(),h=a.get(g),h.success(function(a){return f.success("forked: "+a),e(a)}),h.error(function(a){return f.error("failed to fork",a)})},"delete":function(c){var d,e;return f.debug("deleting"),d=b["delete"](),e=a["delete"](d),e.success(function(a){return f.success("deleted"),c(a)}),e.error(function(a){return f.error("failed to delete",a)})},validate:function(a){var b,c,d;return d=!0,null==(null!=a?a.id:void 0)||null==(null!=a?a.filecontents:void 0)||null==(null!=a?a.filenames:void 0)?(f.debug("validating: false - pad is not complete"),d=!1):(b=function(){var b,d,e,f;for(e=a.filenames,f=[],b=0,d=e.length;d>b;b++)c=e[b],(null==c||""===c)&&f.push(c);return f}().length,0!==b&&(d=!1),f.debug("validating: "+d)),d}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appUrlService",["appContextService",function(a){var b,c;return b=function(){return a.getId()},c="http://107.170.130.41:8080/api/pad",{show:function(){return""+c+"/"+b()},create:function(){return""+c},"delete":function(){return""+c+"/"+b()},syncToServer:function(){return""+c+"/"+b()+"/file"},syncToClient:function(){return""+c+"/"+b()+"/file"},forkApi:function(){return""+c+"/"+b()+"/fork"},downloadApi:function(){return""+c+"/"+b()+"/download"},forkLink:function(){return"/"+b()+"/fork"},downloadLink:function(){return"/"+b()+"/download"},worker:function(){return""+c+"/"+b()+"/worker"}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appEditorService",["appNotificationService",function(a){var b,c,d,e;return d=a,("undefined"==typeof ace||null===ace)&&null!=d&&d.error("ace editor is not avaliable"),c=null,b=null,e={useWorker:!1,theme:"ace/theme/idle_fingers",useSoftTabs:!0,showPrintMargin:!1,vScrollBarAlwaysVisible:!1,useWrapMode:!0,wrapLimitRange:[null,null]},{init:function(a){var f;return d.debug("init editor with "+a),b=ace.edit(a),c=a,f=b.getSession(),f.setUseWorker(e.useWorker),b.setTheme(e.theme),b.setAnimatedScroll(!0),f.setUseSoftTabs(e.useSoftTabs),b.setShowPrintMargin(e.showPrintMargin),b.setOption("vScrollBarAlwaysVisible",e.vScrollBarAlwaysVisible),f.setUseWrapMode(e.useWrapMode),f.setWrapLimitRange(e.wrapLimitRange[0],e.wrapLimitRange[1]),this.setMode("ace/mode/markdown")},getEditor:function(){return b},getCursorStatus:function(){var a,c;return a=b.getSelection().getSelectionLead(),c=b.getSelectionRange(),{row:a.row+1,col:a.column+1,hasSel:!b.selection.isEmpty(),sel:{srow:c.start.row+1,scol:c.start.column+1,erow:c.end.row+1,ecol:c.end.column+1}}},setMode:function(a){return b.getSession().setMode(a)},setText:function(a){return b.getSession().setValue(a)},getText:function(){return b.getSession().getValue()}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appMarkdownService",["appNotificationService",function(a){var b;return b=a,("undefined"==typeof marked||null===marked||"undefined"==typeof hljs||null===hljs)&&b.error("marked/highlightjs is not available"),marked.setOptions({gfm:!0,tables:!0,breaks:!1,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!1,highlight:function(a){return hljs.highlightAuto(a).value}}),{toHtml:function(a){return marked(a)},addClass:function(a){return $(a).find("table").addClass("table")}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appFileService",["appNotificationService","$routeParams",function(a){var b,c,d,e;return b=0,c=!1,d={"ace/mode/markdown":[".*\\.md$","readme.*"],"ace/mode/ats":[".*\\.[ds]ats$"],"ace/mode/c_cpp":[".*\\.[ch]$",".*\\.[ch]ats$"],"ace/mode/java":[".*\\.java$"]},e=a,{active:function(){return b},select:function(a){return b=a},edit:function(a){return c=a},isEditing:function(){return c},validate:function(a){return null==a?!1:/^[A-Za-z0-9_\.\-]+$/.test(a)&&a.length<=64},guessMode:function(a){var b,c,e,f,g,h;c="ace/mode/text";for(b in d)for(f=d[b],g=0,h=f.length;h>g;g++)e=f[g],new RegExp(e,"i").test(a)&&(c=b);return c},isReadme:function(a){return/readme.*/i.test(a)}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appTerminalService",["$http","$timeout","appNotificationService","appUrlService",function(a,b,c,d){var e,f;return e=c,f=!1,{init:function(c,g){var h,i,j=this;return e.debug("init terminal"),f=!1,g=this["default"](g),g.parent=document.getElementById(c),this.open(g),h=d.worker(),i=a.get(h),i.success(function(a){return e.debug("got remote worker: "+a),g.url=a,$.getScript(j.scriptUrl(g.scriptId,a),function(){var a;return a=function(){return j.connect(g)},b(a,1e3*g.initDelay),f=!0})}),i.error(function(a){return e.error("failed to load worker address",a)})},scriptUrl:function(a,b){var c,d;return c=$("<a>",{href:b})[0],d="http://"+c.hostname+":"+c.port+"/console/primus.js"+c.search},isReady:function(){return f},cmd:function(a){return this.term.emit("data",""+a+"\n")},msg:function(a){return this.term.write(""+a+"\r\n"),this.cmd("")},"default":function(a){var b,c,d,e,f,g,h;return{scriptId:null!=(b=null!=a?a.scriptId:void 0)?b:"primus",path:null!=(c=null!=a?a.path:void 0)?c:"/console",url:null!=(d=null!=a?a.url:void 0)?d:"http://localhost:8080",cols:null!=(e=null!=a?a.cols:void 0)?e:180,rows:null!=(f=null!=a?a.rows:void 0)?f:30,parent:null!=(g=null!=a?a.parent:void 0)?g:document.body,initDelay:null!=(h=null!=a?a.initDelay:void 0)?h:3}},term:null,primus:null,open:function(a){var b=this;return null!=this.term&&this.term.destroy(),e.debug("opening terminal"),a=this["default"](a),this.term=new Terminal({cols:a.cols,rows:a.rows,useStyle:!0,screenKeys:!0}),this.term.open(a.parent),this.term.on("data",function(a){return null!=b.primus?b.primus.write(a):void 0})},connect:function(a){var b=this;return e.debug("connecting to worker"),a=this["default"](a),null!=this.primus&&this.primus.end(),this.primus=Primus.connect(a.url),this.primus.on("data",function(a){return b.term.write(a)}),this.primus.on("open",function(){return b.cmd("clear")}),this.primus.on("error",function(){return b.msg("error")}),this.primus.on("reconnecting",function(){return b.msg("reconnecting")})}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appContextService",["appNotificationService",function(a){var b,c,d;return c=a,b=null,d=!1,{reset:function(){return c.debug("reseting context"),b=null,d=!1},getId:function(){return b},setId:function(a){return b=a,c.debug("setting context id: "+a)},ready:function(){return d=!0},isReady:function(){return d}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("appNotificationService",["$log",function(a){var b,c,d,e;return d=[],e=[],c=[],b=!0,{error:function(c,e){return null==e&&(e=null),d.push(c),b?a.debug(c):void 0},debug:function(c){return b?a.debug(c):void 0},success:function(c){return e.push(c),b?a.debug(c):void 0},queues:function(){return{e:d,s:e,d:c}}}}])}.call(this),function(){"use strict";var a=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};angular.module("atsPadApp").directive("appFileList",["appFileService",function(b){var c,d;return d=function(){return less.env="production",less.logLevel=0},c=function(a,b){var c,d;return d=new less.Parser({}),c='@import url("/styles/bootswatch/'+b.name.toLowerCase()+'/variables.less");\n@import url("/styles/filelist.less.keep");',d.parse(c,function(b,c){var d,e,f;return d=c.toCSS(),f="dynStyle",e='<style type="text/css" id="'+f+'">\n	'+d+"\n</style>",$("#"+f).remove(),$(a).before(e)})},{templateUrl:"views/partials/filelist.html",restrict:"A",replace:!1,link:function(e,f){var g,h,i;return e.form={filenames:[]},i=function(a,b,c){return null!=a?c.form.filenames=a.slice(0):void 0},e.$watch("pad.filenames",i,!0),d(),e.$on("app_evt_theme_changed",function(a,b){return c(f,b)}),h=function(){var c,d;return c=b.active(),a.call(function(){d=[];for(var a=0,b=e.form.filenames.length;b>=0?b>a:a>b;b>=0?a++:a--)d.push(a);return d}.apply(this),c)>=0},g=function(a,c,d){var e;return null==a||a?void 0:(e=d.form.filenames.length-1,0>e&&(e=0),b.select(e))},e.$watch(h,g)}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appThemeChooser",["$http","$rootScope",function(a,b){var c,d,e,f;return f=[],c=null,e=null,d=function(){var b;return b=a.get("http://api.bootswatch.com/3/"),b.success(function(a){var b,c,d,g,h;for(f=a.themes,e.empty(),h=[],b=d=0,g=f.length;g>d;b=++d)c=f[b],h.push(e.append($("<option/>").val(b).text(c.name)));return h})},{restrict:"A",link:function(a,g,h){return c=$("#"+h.idCss),e=g,d(),g.on("change",function(){var a,d;return a=$(this).val(),d=f[a],c.attr("href",d.cssCdn),b.$broadcast("app_evt_theme_changed",d)})}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appEditor",["$timeout","appFileService","appEditorService",function(a,b,c){var d;return d=null,{restrict:"AE",link:function(e,f,g){var h,i,j,k,l,m,n;return d=g.id,c.init(d),n=c,j=c.getEditor(),k=function(){return j=c.getEditor(),j.getSession().on("change",function(){return a(function(){var a;return a=b.active(),e.pad.filecontents[a]=n.getText()})})},i=function(){var a,c,d;return a=b.active(),null!=(c=e.pad)&&null!=(d=c.filecontents)?d[a]:void 0},h=function(a){var b,d;return null!=a?(j=c.getEditor(),b=j.getSelection().getCursor(),d=j.getSession().getScrollTop(),n.setText(a),j.clearSelection(),j.moveCursorToPosition(b),j.focus(),j.getSession().setScrollTop(d)):void 0},m=function(){var a,c,d;return a=b.active(),(null!=(c=e.pad)&&null!=(d=c.filenames)?d[a]:void 0)?b.guessMode(e.pad.filenames[a]):void 0},l=function(a){return null!=a?n.setMode(a):void 0},j.getSession().on("change",k),e.$watch(i,h,!0),e.$watch(m,l,!0),$(document).ready(function(){return j=c.getEditor(),j.clearSelection(),j.focus()})}}}])}.call(this),function(){"use strict";var a=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};angular.module("atsPadApp").controller("FilelistCtrl",["$scope","$timeout","appFileService",function(b,c,d){return b.isActive=function(a){return a===d.active()},b.isEditing=function(a){return d.isEditing()&&a===d.active()},b.onSelect=function(a){var c;return a!==d.active()?(c=d.active(),b.isEditing(c)&&(b.onCancel(c),d.edit(!1)),d.select(a)):void 0},b.isReadme=function(a){return d.isReadme(a)},b.onDelete=function(a){var c,d,e;return b.pad.filenames=function(){var c,f,g,h;for(g=b.pad.filenames,h=[],d=c=0,f=g.length;f>c;d=++c)e=g[d],d!==a&&h.push(e);return h}(),b.pad.filecontents=function(){var e,f,g,h;for(g=b.pad.filecontents,h=[],d=e=0,f=g.length;f>e;d=++e)c=g[d],d!==a&&h.push(c);return h}()},b.onEdit=function(){return d.edit(!0)},b.onCancel=function(a){var c;return d.edit(!1),c=b.form.filenames[a],c&&b.pad.filenames[a]?b.form.filenames[a]=b.pad.filenames[a]:b.onDelete(a)},b.onSubmit=function(a){return b.pad.filenames[a]=b.form.filenames[a],d.edit(!1),!0},b.debug=function(a){return console.dir(a)},b.onBlur=function(a){return console.dir("blur"),b.isEditing(a)?b.onCancel(a):void 0},b.validate=function(c,e){var f,g;return d.validate(c)?(f=a.call(b.form.filenames.slice(0,e),c)<0,g=a.call(b.form.filenames.slice(e+1),c)<0,f&&g):!1}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appTooltip",function(){return{restrict:"A",link:function(){}}})}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appReadme",["$timeout","appFileService","appMarkdownService",function(a,b,c){return{templateUrl:"views/partials/readme.html",restrict:"A",link:function(a,d){var e,f;return a.toggle=function(){return d.find(".panel-body").toggleClass("collapse")},f=function(a){var c,d,e,f;return null==a.pad?{title:"README",content:"Please add README for this pad"}:(c=b.active(),d=a.pad.filenames[c],b.isReadme(d)||null!=b.guessMode(d)==="ace/mode/markdown"?{content:a.pad.filecontents[c],title:a.pad.filenames[c]}:(e=function(){var c,d,g,h;for(g=a.pad.filenames,h=[],e=c=0,d=g.length;d>c;e=++c)f=g[e],b.isReadme(f)&&h.push(e);return h}()[0],{content:a.pad.filecontents[e],title:a.pad.filenames[e]}))},e=function(a,b,d){return null!=a?(d.title=a.title,d.content=c.toHtml(a.content)):void 0},a.$watch(f,e,!0),a.$watch(function(){return d.find("article").html()},function(){return c.addClass(d)})}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appTerminal",["appContextService","appTerminalService",function(a,b){return{restrict:"A",link:function(c,d,e){var f,g,h;return f={parent:$(d).get(),cols:null!=e?e.cols:void 0,rows:null!=e?e.rows:void 0},h=function(){return a.isReady()},g=function(a){return a?b.init(e.id,f):void 0},c.$watch(h,g)}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appStatusBar",["appEditorService","$timeout",function(a,b){return{templateUrl:"views/partials/statusbar.html",scope:{},replace:!1,restrict:"A",link:function(c){var d;return c.bar=a.getCursorStatus(),d=a.getEditor().getSession().getSelection(),d.on("changeSelection",function(){return b(function(){return c.bar=a.getCursorStatus()})}),d.on("changeCursor",function(){return b(function(){return c.bar=a.getCursorStatus()})})}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appFileToolbar",function(){return{templateUrl:"views/partials/filetoolbar.html",restrict:"A"}})}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appSidebar",function(){return{templateUrl:"views/partials/sidebar.html",restrict:"A"}})}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appAffix",["appNotificationService","$timeout",function(a,b){var c;return c=a,{restrict:"A",link:function(a,d,e){var f,g,h,i,j,k,l,m,n,o;return f=$(d),k=$(d).parent(),j=function(){return $(e.topLimit).length>0&&$(e.bottomLimit).length>0},i=function(){var a;return a=k.width(),$(d).width(a)},l=function(a){return a-$(window).scrollTop()},m=function(){var a;return null!=(a=$(e.topLimit).offset())?a.top:void 0},h=function(){var a;return l(null!=(a=$(e.bottomLimit).offset())?a.top:void 0)},g=function(){return $(window).resize(function(){return b(function(){return i()})}),$(window).scroll(function(){var a;return j()?(a=m(),a>h()&&(a=h()),10>a&&(a=10),f.css("top",a)):void 0}),$(".ats-pad-header").bind("DOMSubtreeModified",function(){var a;return j()?(a=m(),a>h()&&(a=h()),10>a&&(a=10),f.css("top",a)):void 0}),$(document).ready(function(){return j()?b(function(){return f.css("top",m()),i()}):void 0})},null==(null!=(n=$(e.topLimit).offset())?n.top:void 0)||null==(null!=(o=$(e.bottomLimit).offset())?o.top:void 0)?c.debug("Can't init app-affix"):(f.css("top",m()),f.css("z-index",1e3),g())}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").constant("appTermClient",{"default":function(a){var b,c,d,e,f,g,h,i,j;return{path:null!=(b=null!=a?a.path:void 0)?b:"/console",remote:null!=(c=null!=a?a.remote:void 0)?c:"http://localhost:8080",reconnection_delay:null!=(d=null!=a?a.reconnection_delay:void 0)?d:500,max_reconnection_attempts:null!=(e=null!=a?a.max_reconnection_attempts:void 0)?e:20,cols:null!=(f=null!=a?a.cols:void 0)?f:180,rows:null!=(g=null!=a?a.rows:void 0)?g:30,parent:null!=(h=null!=a?a.parent:void 0)?h:document.body,connect_timeout:null!=(i=null!=a?a.connect_timeout:void 0)?i:1e4,focus:null!=(j=null!=a?a.focus:void 0)?j:!1}},term:null,socket:null,open:function(a){return null==this.term?(console.log("OPENING"),a=this["default"](a),this.term=new Terminal({cols:a.cols,rows:a.rows,useStyle:!0,screenKeys:!0}),this.term.open(a.parent)):void 0},cleanup:function(){return console.log("CLOSING"),null!=this.socket&&(console.log("cleaning up socket"),console.dir(this.socket),this.socket.close(),delete this.socket,this.socket=null),null!=this.term?(console.log("cleaning up term"),this.term.destroy(),delete this.term,this.term=null):void 0},run:function(a){var b,c=this;return console.log("RUNNING"),null==this.term&&this.open(a),a=this["default"](a),console.dir(io),b=io.connect(a.remote,{path:a.path,connectTimeout:a.connect_timeout,reconnectionDelay:a.reconnection_delay,maxReconnectionAttempts:2,forceNew:!0}),this.socket=b,this.term.write("Connecting to "+a.remote+"\r\n"),this.term.on("data",function(a){return b.emit("data",a)}),b.on("data",function(a){return c.term.write(a)}),b.on("reconnecting",function(a){return c.term.write("Reconnecting: "+a+"\r\n")}),b.on("reconnect_error",function(){return c.term.write("Reconnection error \r\n"),c.cleanup(),c.run(a)}),b.on("reconnect_failed",function(){return c.term.write("Reconnection failed\r\n"),c.cleanup(),c.run(a)}),b.on("error",function(){return c.term.write("Connection error \r\n"),c.cleanup(),c.run(a)}),b.on("reconnect",function(){return c.term.emit("data","\nclear\n")}),b.on("connect",function(){return c.term.emit("data","\nclear\n")}),b.on("disconnect",function(){return c.term.write("\r\nDisconnected\r\n")})}})}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appLoading",["appContextService",function(a){return{templateUrl:"views/partials/loading.html",restrict:"A",replace:!1,scope:{},link:function(b,c){var d,e;return e=function(){return a.isReady()},d=function(a){return a?$(c).fadeOut("slow"):$(c).fadeIn("slow")},b.$watch(e,d)}}}])}.call(this),function(){"use strict";angular.module("atsPadApp").factory("testPad",function(){var a,b,c;return c='# Snowplow\n\n![snowplow] [snowplow-logo]\n\nSnowplow is an enterprise-strength marketing and product analytics platform. It does three things:\n\n1. Identifies your users, and tracks the way they engage with your website or application\n2. Stores your users\' behavioural data in a scalable "event data warehouse" you control: in Amazon S3 and (optionally) Amazon Redshift or Postgres\n3. Lets you leverage the biggest range of tools to analyse that data incl. big data toolset (e.g. Hive, Pig, Mahout) via EMR or more traditional tools e.g. Tableau, R, Chartio to analyse that behavioural data\n\n**To find out more, please check out the [Snowplow website] [website] and the [Snowplow wiki] [wiki].**\n\n## Snowplow technology 101\n\nThe repository structure follows the conceptual architecture of Snowplow, which consists of five loosely coupled stages:\n\n![architecture] [architecture-image]\n\nTo briefly explain these five sub-systems:\n\n* **Trackers** fire Snowplow events. Currently we have JavaScript, no-JavaScript (pixel), Lua and Arduino trackers\n* **Collectors** receive Snowplow events from trackers. Currently we have a CloudFront-based collector and a Clojure-based collector\n* **Enrich** cleans up the raw Snowplow events, enriches them and puts them into storage. Currently we have a Hadoop-based enrichment processes\n* **Storage** is where the Snowplow events live. Currently we store the Snowplow events in a flatfile structure on S3, and in the Redshift and Postgres databases\n* **Analytics** are performed on the Snowplow events. Currently we have a set of recipes and cubes as SQL views for both Redshift and Postgres, and an online cookbook of ad hoc analyses that work with Redshift, Postgres and Hive \n\n**For more information on the current Snowplow architecture, please see the [Technical architecture] [architecture-doc]**.\n\n\n## Contributing\n\nWe\'re committed to a loosely-coupled architecture for Snowplow and would love to get your contributions within each of the five sub-systems.\n\nIf you would like help implementing a new tracker, adding an additional enrichment or loading Snowplow events into an alternative database, check out our **[Contributing] [contributing]** page on the wiki!\n\n## Questions or need help?\n\nCheck out the **[Talk to us] [talk-to-us]** page on our wiki.\n\n## Copyright and license\n\nSnowplow is copyright 2012-2013 Snowplow Analytics Ltd.\n\nLicensed under the **[Apache License, Version 2.0] [license]** (the "License");\nyou may not use this software except in compliance with the License.\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n[snowplow-logo]: https://d3i6fms1cm1j0i.cloudfront.net/github-wiki/images/snowplow-logo-large.png\n[website]: http://snowplowanalytics.com\n[wiki]: https://github.com/snowplow/snowplow/wiki\n[architecture-image]: https://d3i6fms1cm1j0i.cloudfront.net/github-wiki/images/technical-architecture.png\n[architecture-doc]: https://github.com/snowplow/snowplow/wiki/Technical-architecture\n[talk-to-us]: https://github.com/snowplow/snowplow/wiki/Talk-to-us\n[contributing]: https://github.com/snowplow/snowplow/wiki/Contributing\n[license]: http://www.apache.org/licenses/LICENSE-2.0\n[setup]: https://github.com/snowplow/snowplow/wiki/Setting-up-SnowPlow\n[tech-docs]: https://github.com/snowplow/snowplow/wiki/SnowPlow%20technical%20documentation\n[tracker-protocol]: https://github.com/snowplow/snowplow/wiki/snowplow-tracker-protocol\n[collector-logs]: https://github.com/snowplow/snowplow/wiki/Collector-logging-formats\n[data-structure]: https://github.com/snowplow/snowplow/wiki/canonical-event-model\n\n[techdocs-image]: https://d3i6fms1cm1j0i.cloudfront.net/github/images/techdocs.png\n[setup-image]: https://d3i6fms1cm1j0i.cloudfront.net/github/images/setup.png\n[roadmap-image]: https://d3i6fms1cm1j0i.cloudfront.net/github/images/roadmap.png\n[contributing-image]: https://d3i6fms1cm1j0i.cloudfront.net/github/images/contributing.png\n\n[techdocs]: https://github.com/snowplow/snowplow/wiki/SnowPlow-technical-documentation\n[setup]: https://github.com/snowplow/snowplow/wiki/Setting-up-SnowPlow\n[roadmap]: https://github.com/snowplow/snowplow/wiki/Product-roadmap\n[contributing]: https://github.com/snowplow/snowplow/wiki/Contributing',a='(***********************************************************************)\n(*                                                                     *)\n(*                         Applied Type System                         *)\n(*                                                                     *)\n(***********************************************************************)\n\n(*\n** ATS/Postiats - Unleashing the Potential of Types!\n** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.\n** All rights reserved\n**\n** ATS is free software;  you can  redistribute it and/or modify it under\n** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the\n** Free Software Foundation; either version 3, or (at  your  option)  any\n** later version.\n** \n** ATS is distributed in the hope that it will be useful, but WITHOUT ANY\n** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or\n** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License\n** for more details.\n** \n** You  should  have  received  a  copy of the GNU General Public License\n** along  with  ATS;  see the  file COPYING.  If not, please write to the\n** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA\n** 02110-1301, USA.\n*)\n\n(* ****** ****** *)\n//\n// Author: Hongwei Xi\n// Authoremail: gmhwxi AT gmail DOT com\n// Start Time: October, 2012\n//\n(* ****** ****** *)\n\nstaload "./pats_basics.sats"\n\n(* ****** ****** *)\n\nstaload\nSTMP = "./pats_stamp.sats"\ntypedef stamp = $STMP.stamp\n\n(* ****** ****** *)\n\nstaload\nLAB = "./pats_label.sats"\ntypedef label = $LAB.label\n\n(* ****** ****** *)\n//\nstaload\nFIL = "./pats_filename.sats"\ntypedef filename = $FIL.filename\n//\nstaload LOC = "./pats_location.sats"\ntypedef location = $LOC.location\n//\n(* ****** ****** *)\n\nstaload\nSYM = "./pats_symbol.sats"\ntypedef symbol = $SYM.symbol\n\n(* ****** ****** *)\n\nstaload\nSYN = "./pats_syntax.sats"\ntypedef i0nt = $SYN.i0nt\ntypedef f0loat = $SYN.f0loat\n\n(* ****** ****** *)\n\nstaload "./pats_staexp2.sats"\n\n(* ****** ****** *)\n\nstaload\nS2EUT =\n"./pats_staexp2_util.sats"\nvtypedef stasub = $S2EUT.stasub \n\n(* ****** ****** *)\n\nstaload "./pats_dynexp2.sats"\n\n(* ****** ****** *)\n\nstaload "./pats_histaexp.sats"\nstaload "./pats_hidynexp.sats"\n\n(* ****** ****** *)\n\nfun the_exndeclst_get (): hideclist\nfun the_exndeclst_add (hid: hidecl): void\n\n(* ****** ****** *)\n\nfun the_saspdeclst_get (): hideclist\nfun the_saspdeclst_add (hid: hidecl): void\n\n(* ****** ****** *)\n\nfun the_extypelst_get (): hideclist\nfun the_extypelst_add (hid: hidecl): void\n\n(* ****** ****** *)\n\nfun the_extcodelst_get (): hideclist\nfun the_extcodelst_add (hid: hidecl): void\n\n(* ****** ****** *)\n\nfun the_staloadlst_get (): hideclist\nfun the_staloadlst_add (hid: hidecl): void\n\nfun the_dynloadlst_get (): hideclist\nfun the_dynloadlst_add (hid: hidecl): void\n\n(* ****** ****** *)\n\nfun the_dynconlst_get (): d2conlst\nfun the_dynconlst_add (d2c: d2con): void\n\n(* ****** ****** *)\n\nfun the_dyncstlst_get (): d2cstlst\nfun the_dyncstlst_add (d2c: d2cst): void\n\n(* ****** ****** *)\n\nabstype tmplab_type\ntypedef tmplab = tmplab_type\ntypedef tmplabopt = Option (tmplab)\n\n(* ****** ****** *)\n\nfun tmplab_make (loc: location): tmplab\nfun tmplab_get_loc (x: tmplab): location\nfun tmplab_get_stamp (x: tmplab): stamp\n\n(* ****** ****** *)\n\nfun print_tmplab (x: tmplab): void\nfun prerr_tmplab (x: tmplab): void\noverload print with print_tmplab\noverload prerr with prerr_tmplab\nfun fprint_tmplab : fprint_type (tmplab)\noverload fprint with fprint_tmplab\n\n(* ****** ****** *)\n\nabstype tmpvar_type\ntypedef tmpvar = tmpvar_type\n//\ntypedef tmpvarlst = List (tmpvar)\ntypedef tmpvaropt = Option (tmpvar)\n//\nvtypedef tmpvarlst_vt = List_vt (tmpvar)\nvtypedef tmpvaropt_vt = Option_vt (tmpvar)\n\n(* ****** ****** *)\n\nabsvtype tmpvarset_vtype\nvtypedef tmpvarset_vt = tmpvarset_vtype\n\nabsvtype tmpvarmap_vtype (a:type)\nvtypedef tmpvarmap_vt (a:type) = tmpvarmap_vtype (a)\n\n(* ****** ****** *)\n\nfun tmpvar_make\n  (loc: location, hse: hisexp): tmpvar\nfun tmpvar_make_ref\n  (loc: location, hse: hisexp): tmpvar\nfun tmpvar_make_ret\n  (loc: location, hse: hisexp): tmpvar\n\n(* ****** ****** *)\n\nfun tmpvar_copy_err (tmp: tmpvar): tmpvar\n\n(* ****** ****** *)\n\nfun tmpvar_get_loc (tmp: tmpvar): location\n\nfun tmpvar_get_type (tmp: tmpvar): hisexp\n\nfun tmpvar_isref (tmp: tmpvar): bool // tmpref?\nfun tmpvar_isret (tmp: tmpvar): bool // tmpret?\nfun tmpvar_iserr (tmp: tmpvar): bool // tmperr?\n\nfun tmpvar_get_topknd\n  (tmp: tmpvar): int // knd=0/1: local/(static)top\n\nfun tmpvar_get_origin (tmp: tmpvar): tmpvaropt\nfun tmpvar_get_suffix (tmp: tmpvar): int\n\nfun tmpvar_get_stamp (tmp: tmpvar): stamp // unicity\n\n(* ****** ****** *)\n\nfun tmpvar_get_tailcal (tmp: tmpvar): int // if >= 2\nfun tmpvar_inc_tailcal (tmp: tmpvar): void // incby 1\n\n(* ****** ****** *)\n\nfun tmpvar_set_tyclo (tmp: tmpvar, fl: funlab): void\n\n(* ****** ****** *)\n//\nfun print_tmpvar (x: tmpvar): void\nfun prerr_tmpvar (x: tmpvar): void\nfun fprint_tmpvar : fprint_type (tmpvar)\nfun fprint_tmpvaropt : fprint_type (tmpvaropt)\n//\noverload print with print_tmpvar\noverload prerr with prerr_tmpvar\noverload fprint with fprint_tmpvar\noverload fprint with fprint_tmpvaropt\n//\n(* ****** ****** *)\n\nfun eq_tmpvar_tmpvar (x1: tmpvar, x2: tmpvar):<> bool\noverload = with eq_tmpvar_tmpvar\nfun compare_tmpvar_tmpvar (x1: tmpvar, x2: tmpvar):<> int\noverload compare with compare_tmpvar_tmpvar\n\n(* ****** ****** *)\n\nfun tmpvarset_vt_nil ():<> tmpvarset_vt\nfun tmpvarset_vt_free (xs: tmpvarset_vt):<> void\nfun tmpvarset_vt_add (xs: tmpvarset_vt, x: tmpvar):<> tmpvarset_vt\nfun tmpvarset_vt_listize (xs: !tmpvarset_vt):<> tmpvarlst_vt\nfun tmpvarset_vt_listize_free (xs: tmpvarset_vt):<> tmpvarlst_vt\n\n(* ****** ****** *)\n\nfun tmpvarmap_vt_nil {a:type} ():<> tmpvarmap_vt (a)\nfun tmpvarmap_vt_free {a:type} (map: tmpvarmap_vt(a)):<> void\n\nfun tmpvarmap_vt_search\n  {a:type} (map: !tmpvarmap_vt(a), tmp: tmpvar): Option_vt (a)\nfun tmpvarmap_vt_insert\n  {a:type} (map: &tmpvarmap_vt(a), tmp: tmpvar, x: a): bool(*found*)\nfun tmpvarmap_vt_remove\n  {a:type} (map: &tmpvarmap_vt(a), tmp: tmpvar): bool(*found*)\n\n(* ****** ****** *)\n//\nabstype d2env_type\n//\ntypedef d2env = d2env_type\n//\ntypedef d2envlst = List (d2env)\nvtypedef d2envlst_vt = List_vt (d2env)\n//\ntypedef d2envlstopt = Option (d2envlst)\n//\n(* ****** ****** *)\n\nfun d2var2env (d2v: d2var): d2env\n\nfun d2env_get_var (x: d2env):<> d2var\nfun d2env_get_type (x: d2env):<> hisexp\nfun d2env_make (d2v: d2var, hse: hisexp): d2env\n\nfun fprint_d2env : fprint_type (d2env)\noverload fprint with fprint_d2env\nfun fprint_d2envlst : fprint_type (d2envlst)\noverload fprint with fprint_d2envlst\n\nfun fprint_d2envlstopt : fprint_type (d2envlstopt)\noverload fprint with fprint_d2envlstopt\n\n(* ****** ****** *)\n\nabsvtype d2envset_vtype\nvtypedef d2envset_vt = d2envset_vtype\n\nfun d2envset_vt_nil ():<> d2envset_vt\nfun d2envset_vt_free (xs: d2envset_vt): void\nfun d2envset_vt_ismem (xs: !d2envset_vt, x: d2env):<> bool\nfun d2envset_vt_add (xs: d2envset_vt, x: d2env):<> d2envset_vt\nfun d2envset_vt_listize (xs: !d2envset_vt):<> List_vt (d2env)\nfun d2envset_vt_listize_free (xs: d2envset_vt):<> List_vt (d2env)\n\nfun d2envlst2set (d2es: d2envlst): d2envset_vt\n\n(* ****** ****** *)\n//\n// HX: function label\n//\nabstype ccomp_funlab_type\ntypedef funlab = ccomp_funlab_type\ntypedef funlablst = List (funlab)\nvtypedef funlablst_vt = List_vt (funlab)\ntypedef funlabopt = Option (funlab)\nvtypedef funlabopt_vt = Option_vt (funlab)\n//\ntypedef funlablstopt = Option (funlablst)\n//\nfun print_funlab (x: funlab): void\nfun prerr_funlab (x: funlab): void\noverload print with print_funlab\noverload prerr with prerr_funlab\n//\nfun fprint_funlab : fprint_type (funlab)\noverload fprint with fprint_funlab\nfun fprint_funlablst : fprint_type (funlablst)\noverload fprint with fprint_funlablst\n//\nfun fprint_funlablstopt : fprint_type (funlablstopt)\noverload fprint with fprint_funlablstopt\n//\n(* ****** ****** *)\n//\nfun\nfunlab_make\n(\n  name: string\n, level: int\n, hse0: hisexp\n, fcopt: fcopt_vt\n, qopt: d2cstopt\n, sopt: d2varopt\n, t2mas: t2mpmarglst\n, stamp: stamp\n) : funlab // end of [funlab_make]\n//\nfun funlab_make_type (hse: hisexp): funlab\n//\nfun funlab_make_dcst_type\n  (d2c: d2cst, hse: hisexp, opt: fcopt_vt): funlab\nfun funlab_make_dvar_type\n  (d2v: d2var, hse: hisexp, opt: fcopt_vt): funlab\n//\nfun funlab_make_tmpcst_type\n(\n  d2c: d2cst, t2ms: t2mpmarglst, hse: hisexp, opt: fcopt_vt\n) : funlab // endfun\nfun funlab_make_tmpvar_type\n(\n   d2v: d2var, t2ms: t2mpmarglst, hse: hisexp, opt: fcopt_vt\n) : funlab // endfun\n//\n(* ****** ****** *)\n//\nfun funlab_get_name (flab: funlab): string\n//\nfun funlab_get_level (flab: funlab): int\n//\nfun funlab_get_tmpknd (flab: funlab): int\nfun funlab_set_tmpknd (flab: funlab, knd: int): void\n//\nfun funlab_get_d2copt (flab: funlab): d2cstopt // global\nfun funlab_get_d2vopt (flab: funlab): d2varopt // static\n//\nfun funlab_get_type (flab: funlab): hisexp\nfun funlab_get_funclo (flab: funlab): funclo\nfun funlab_get_type_arg (flab: funlab): hisexplst\nfun funlab_get_type_res (flab: funlab): hisexp\n//\nfun funlab_get_ncopy (flab: funlab): int\nfun funlab_set_ncopy (flab: funlab, cnt: int): void\nfun funlab_incget_ncopy (flab: funlab): int\n//\nfun funlab_get_origin (flab: funlab): funlabopt\nfun funlab_set_origin (flab: funlab, opt: funlabopt): void\n//\nfun funlab_get_suffix (flab: funlab): int\nfun funlab_set_suffix (flab: funlab, sfx: int): void\n//\nfun funlab_get_tmparg (flab: funlab): t2mpmarglst\n//\nfun funlab_get_stamp (flab: funlab):<> stamp\n//\n(* ****** ****** *)\n\nfun funlab_is_envful (flab: funlab): bool\n\n(* ****** ****** *)\n//\n// HX: obtaining env+arg-list\n//\nfun funlab_get_type_fullarg (flab: funlab): hisexplst\n\n(* ****** ****** *)\n\nabsvtype funlabset_vtype\nvtypedef funlabset_vt = funlabset_vtype\n\nfun funlabset_vt_nil (): funlabset_vt\nfun funlabset_vt_free (fls: funlabset_vt): void\nfun funlabset_vt_ismem (fls: !funlabset_vt, fl: funlab): bool\nfun funlabset_vt_add (fls: funlabset_vt, fl: funlab): funlabset_vt\nfun funlabset_vt_listize (fls: !funlabset_vt): funlablst_vt\nfun funlabset_vt_listize_free (fls: funlabset_vt): funlablst_vt\n\nfun funlablst2set (fls: funlablst): funlabset_vt\n\nfun fprint_funlabset_vt (out: FILEref, fls: !funlabset_vt): void\noverload fprint with fprint_funlabset_vt\n\n(* ****** ****** *)\n//\n// HX: function entry\n//\nabstype funent_type\ntypedef funent = funent_type\ntypedef funentlst = List (funent)\ntypedef funentopt = Option (funent)\nvtypedef funentopt_vt = Option_vt (funent)\n//\nfun print_funent (x: funent): void\noverload print with print_funent\nfun prerr_funent (x: funent): void\noverload prerr with prerr_funent\nfun fprint_funent : fprint_type (funent)\noverload fprint with fprint_funent\n//\n(* ****** ****** *)\n\nfun funent_is_tmplt (feng: funent): bool\n\n(* ****** ****** *)\n\nfun funent_get_loc (fent: funent): location\n//\nfun funent_get_lab (fent: funent): funlab\n//\nfun funent_get_level (fent: funent): int\n//\nfun funent_get_imparg (fent: funent): s2varlst\nfun funent_get_tmparg (fent: funent): s2explstlst\n//\nfun funent_get_tmpret (fent: funent): tmpvar // return value\n//\nfun funent_get_flablst (fent: funent): funlablst\nfun funent_get_flablst_fin (fent: funent): Option (funlablst)\n//\nfun funent_get_d2envlst (fent: funent): d2envlst\nfun funent_get_d2envlst_fin (fent: funent): Option (d2envlst)\n//\nfun funent_get_tmpvarlst (fent: funent): tmpvarlst\n//\nfun funent_get_fnxlablst (fent: funent): funlablst\nfun funent_set_fnxlablst\n  (fent: funent, fls: funlablst): void = "patsopt_funent_set_fnxlablst"\n//\n(* ****** ****** *)\n(*\n// HX: transitive closure of called functions\n*)\nfun funent_eval_flablst (fent: funent): funlablst\n(*\n// HX: environvals occurring in called functions\n*)\nfun funent_eval_d2envlst (fent: funent): d2envlst\n//\n(* ****** ****** *)\n\nfun funlab_get_funent (flab: funlab): funentopt\nfun funlab_set_funent (flab: funlab, opt: funentopt): void\n\n(* ****** ****** *)\n\nfun the_funlablst_get (): funlablst\nfun the_funlablst_add (flab: funlab): void\nfun the_funlablst_addlst (fls: funlablst): void\n\n(* ****** ****** *)\n\ndatatype tmpsub =\n  | TMPSUBcons of (s2var, s2exp, tmpsub) | TMPSUBnil of ()\ntypedef tmpsubopt = Option (tmpsub)\nvtypedef tmpsubopt_vt = Option_vt (tmpsub)\n \nfun fprint_tmpsub : fprint_type (tmpsub)\nfun fprint_tmpsubopt : fprint_type (tmpsubopt)\n\n(* ****** ****** *)\n\noverload fprint with fprint_tmpsub\noverload fprint with fprint_tmpsubopt\n\n(* ****** ****** *)\n\nfun tmpsub2stasub (xs: tmpsub): stasub\nfun tmpsub_append (xs1: tmpsub, xs2: tmpsub): tmpsub\n\n(* ****** ****** *)\n\ndatatype\ntmpcstmat =\n  | TMPCSTMATsome of (hiimpdec, tmpsub)\n  | TMPCSTMATsome2 of (d2cst, s2explstlst, funlab)\n  | TMPCSTMATnone of ()\n// end of [tmpcstmat]\n\nfun fprint_tmpcstmat : fprint_type (tmpcstmat)\nfun fprint_tmpcstmat_kind : fprint_type (tmpcstmat) // 1/0:found/not\n\n(* ****** ****** *)\n\ndatatype\ntmpvarmat =\n  | TMPVARMATsome of (hifundec, tmpsub)\n  | TMPVARMATsome2 of (d2var, s2explstlst, funlab)\n  | TMPVARMATnone of ()\n// end of [tmpvarmat]\n\nfun fprint_tmpvarmat : fprint_type (tmpvarmat)\nfun fprint_tmpvarmat_kind : fprint_type (tmpvarmat) // 1/0:found/not\n\n(* ****** ****** *)\n\noverload fprint with fprint_tmpcstmat\noverload fprint with fprint_tmpvarmat\n\n(* ****** ****** *)\n\nabstype ccomp_instrlst_type\ntypedef instrlst = ccomp_instrlst_type\n\n(* ****** ****** *)\n\ndatatype\nprimcstsp =\n  | PMCSTSPmyfil of (filename)\n  | PMCSTSPmyloc of (location)\n  | PMCSTSPmyfun of (funlab) // HX: for function name\n// end of [primcstsp]\n\nfun fprint_primcstsp : fprint_type (primcstsp)\n\n(* ****** ****** *)\n\ndatatype\nprimdec_node =\n//\n  | PMDnone of () \n  | PMDlist of (primdeclst)\n//\n  | PMDsaspdec of (s2aspdec)\n//\n  | PMDdatdecs of (s2cstlst)\n  | PMDexndecs of (d2conlst)\n//\n  | PMDfundecs of (\n	  funkind, s2qualst, hifundeclst\n	) // end of [PMDfundecs]\n//\n  | PMDvaldecs of\n	  (valkind, hivaldeclst, instrlst)\n	// end of [PMDvaldecs]\n  | PMDvaldecs_rec of\n	  (valkind, hivaldeclst, instrlst)\n	// end of [PMDvaldecs_rec]\n//\n  | PMDvardecs of (hivardeclst, instrlst)\n//\n  | PMDimpdec of (hiimpdec)\n//\n  | PMDinclude of (int(*knd*), primdeclst)\n//\n  | PMDstaload of (hidecl) // HX: staloading\n//\n  | PMDstaloadloc of (filename, symbol, primdeclst)\n//\n  | PMDdynload of (hidecl) // HX: dynloading\n//\n  | PMDlocal of (primdeclst, primdeclst)\n// end of [primdec_node]\n\nand primval_node =\n//\n  | PMVtmp of (tmpvar) // temporary variables\n  | PMVtmpref of (tmpvar) // for addresses of temporary variables\n//\n  | PMVarg of (int)\n  | PMVargref of (int) // call-by-reference\n  | PMVargtmpref of (int) // call-by-reference but treated as tmpvar\n  | PMVargenv of (int) // arguments for environvals\n//\n  | PMVcst of (d2cst) // for constants\n  | PMVenv of (d2var) // for environvals\n//\n  | PMVint of (int)\n  | PMVintrep of (string)\n//\n  | PMVbool of (bool)\n  | PMVchar of (char)\n  | PMVfloat of (double)\n  | PMVstring of (string)\n//\n  | PMVi0nt of (i0nt)\n  | PMVf0loat of (f0loat)\n//\n  | PMVsizeof of (hisexp)\n//\n  | PMVcstsp of (primcstsp)\n//\n  | PMVtop of ()\n  | PMVempty of ()\n//\n  | PMVextval of (string(*name*))\n//\n  | PMVcastfn of (d2cst, primval)\n//\n  | PMVselcon of (primval, hisexp(*tysum*), label)\n  | PMVselect of (primval, hisexp(*tyroot*), primlab)\n  | PMVselect2 of (primval, hisexp(*tyroot*), primlablst)\n//\n  | PMVselptr of (primval, hisexp(*tyroot*), primlablst)\n//\n  | PMVptrof of (primval)\n  | PMVptrofsel of (primval, hisexp(*tyroot*), primlablst)\n//\n  | PMVrefarg of (int(*knd*), int(*freeknd*), primval)\n//\n  | PMVfunlab of (funlab)\n  | PMVcfunlab of (int(*knd*), funlab)\n//\n  | PMVd2vfunlab of (d2var, funlab) // for fundecloc relocation\n//\n  | PMVlamfix of (int(*knd*), primval) // knd=0/1:lam/fix\n//\n  | PMVtmpltcst of (d2cst, t2mpmarglst) // for template constants\n  | PMVtmpltvar of (d2var, t2mpmarglst) // for template variables\n//\n  | PMVtmpltcstmat of (d2cst, t2mpmarglst, tmpcstmat) // for matched template constants\n  | PMVtmpltvarmat of (d2var, t2mpmarglst, tmpvarmat) // for matched template variables\n//\n  | PMVerr of ()\n// end of [primval_node]\n\nand primlab_node =\n  | PMLlab of (label) | PMLind of (primvalist(*ind*))\n// end of [primlab]\n\nand labprimval = LABPRIMVAL of (label, primval)\n\n(* ****** ****** *)\n\nwhere\nprimdec = \'{\n  primdec_loc= location\n, primdec_node= primdec_node\n} // end of [primdec]\n\nand primdeclst = List (primdec)\nand primdeclst_vt = List_vt (primdec)\n\nand primval =\n\'{\n  primval_loc= location\n, primval_type= hisexp\n, primval_node= primval_node\n} // end of [primval]\n\nand primvalist = List (primval)\nand primvalist_vt = List_vt (primval)\nand primvalopt = Option (primval)\n\nand labprimvalist = List (labprimval)\nand labprimvalist_vt = List_vt (labprimval)\n\nand primlab =\n\'{\n  primlab_loc= location\n, primlab_node= primlab_node\n} // end of [primlab]\n\nand primlablst = List (primlab)\n\n(* ****** ****** *)\n\nfun print_primdec (pmd: primdec): void\noverload print with print_primdec\nfun prerr_primdec (pmd: primdec): void\noverload prerr with prerr_primdec\nfun fprint_primdec : fprint_type (primdec)\nfun fprint_primdeclst : fprint_type (primdeclst)\n\n(* ****** ****** *)\n\nfun primdec_none (loc: location): primdec\n\n(* ****** ****** *)\n\nfun primdec_list (loc: location, pmds: primdeclst): primdec\n\n(* ****** ****** *)\n\nfun primdec_saspdec\n  (loc: location, d2c: s2aspdec): primdec\n// end of [primdec_saspdec]\n\n(* ****** ****** *)\n\nfun primdec_datdecs\n  (loc: location, s2cs: s2cstlst): primdec\n// end of [primdec_datdecs]\n\nfun primdec_exndecs\n  (loc: location, d2cs: d2conlst): primdec\n// end of [primdec_exndecs]\n\n(* ****** ****** *)\n\nfun primdec_fundecs (\n  loc: location, knd: funkind, decarg: s2qualst, hfds: hifundeclst\n) : primdec // end of [primdec_fundecs]\n\n(* ****** ****** *)\n\nfun primdec_valdecs (\n  loc: location, knd: valkind, hvds: hivaldeclst, inss: instrlst\n) : primdec // end of [primdec_valdecs]\nfun primdec_valdecs_rec (\n  loc: location, knd: valkind, hvds: hivaldeclst, inss: instrlst\n) : primdec // end of [primdec_valdecs_rec]\n\n(* ****** ****** *)\n\nfun primdec_vardecs\n  (loc: location, hvds: hivardeclst, inss: instrlst): primdec\n// end of [primdec_vardecs]\n\n(* ****** ****** *)\n\nfun primdec_impdec\n  (loc: location, imp: hiimpdec): primdec\n// end of [primdec_impdec]\n\n(* ****** ****** *)\n\nfun primdec_include\n  (loc: location, knd: int, pmds: primdeclst): primdec\n\n(* ****** ****** *)\n//\nfun primdec_staload (loc: location, hid: hidecl): primdec\n//\nfun primdec_staloadloc\n(\n  loc: location, pfil: filename, nspace: symbol, pmds: primdeclst\n) : primdec // end of [primdec_staloadloc]\n//\nfun primdec_dynload (loc: location, hid: hidecl): primdec\n//\n(* ****** ****** *)\n\nfun primdec_local\n  (loc: location, _head: primdeclst, _body: primdeclst): primdec\n// end of [primdec_local]\n\n(* ****** ****** *)\n//\nfun print_primval (x: primval): void\nfun prerr_primval (x: primval): void\n//\noverload print with print_primval\noverload prerr with prerr_primval\n//\nfun fprint_primval : fprint_type (primval)\nfun fprint_primvalist : fprint_type (primvalist)\n//\noverload fprint with fprint_primval\noverload fprint with fprint_primvalist\n//\n(* ****** ****** *)\n//\nfun fprint_primlab : fprint_type (primlab)\nfun fprint_primlablst : fprint_type (primlablst)\n//\noverload fprint with fprint_primlab\noverload fprint with fprint_primlablst\n//\n(* ****** ****** *)\n\nfun fprint_labprimvalist : fprint_type (labprimvalist)\n\n(* ****** ****** *)\n\nfun tmpvar_is_void (tmp: tmpvar): bool\n\n(* ****** ****** *)\n\nfun primval_is_void (pmv: primval): bool\n\n(* ****** ****** *)\n\nfun primval_is_top (pmv: primval): bool (* uninitiated *)\nfun primval_is_empty (pmv: primval): bool (* value of size(0) *)\n\n(* ****** ****** *)\n\nfun primval_is_nshared (pmv: primval): bool // left-val/field-sel\n\n(* ****** ****** *)\n\nfun primlab_is_lab (pml: primlab): bool\nfun primlab_is_ind (pml: primlab): bool\n\n(* ****** ****** *)\n\nfun primval_tmp\n  (loc: location, hse: hisexp, tmp: tmpvar): primval\nfun primval_tmpref\n  (loc: location, hse: hisexp, tmp: tmpvar): primval\n\n(* ****** ****** *)\n\nfun primval_arg\n  (loc: location, hse: hisexp, narg: int): primval\nfun primval_argref\n  (loc: location, hse: hisexp, narg: int): primval\nfun primval_argtmpref\n  (loc: location, hse: hisexp, narg: int): primval\nfun primval_argenv\n  (loc: location, hse: hisexp, nenv: int): primval\n\n(* ****** ****** *)\n\nfun primval_cst\n  (loc: location, hse: hisexp, d2c: d2cst): primval\n// end of [primval_cst]\n\nfun primval_env\n  (loc: location, hse: hisexp, d2v: d2var): primval\n// end of [primval_env]\n\n(* ****** ****** *)\n\nfun primval_int\n  (loc: location, hse: hisexp, i: int): primval\nfun primval_intrep\n  (loc: location, hse: hisexp, rep: string): primval\n\n(* ****** ****** *)\n\nfun primval_bool\n  (loc: location, hse: hisexp, b: bool): primval\nfun primval_char\n  (loc: location, hse: hisexp, c: char): primval\nfun primval_float\n  (loc: location, hse: hisexp, f: double): primval\nfun primval_string\n  (loc: location, hse: hisexp, str: string): primval\n\n(* ****** ****** *)\n\nfun primval_i0nt\n  (loc: location, hse: hisexp, tok: i0nt): primval\nfun primval_f0loat\n  (loc: location, hse: hisexp, tok: f0loat): primval\n\n(* ****** ****** *)\n\nfun primval_sizeof\n  (loc: location, hse: hisexp, hselt: hisexp): primval\n// end of [primval_sizeof]\n\n(* ****** ****** *)\n\nfun primval_cstsp\n  (loc: location, hse: hisexp, cstsp: primcstsp): primval\n// end of [primval_cstsp]\n\n(* ****** ****** *)\n\nfun primval_top (loc: location, hse: hisexp): primval\nfun primval_empty (loc: location, hse: hisexp): primval\n\n(* ****** ****** *)\n\nfun primval_extval\n  (loc: location, hse: hisexp, name: string): primval\n// end of [primval_extval]\n\n(* ****** ****** *)\n\nfun primval_castfn\n(\n  loc: location, hse: hisexp, d2c: d2cst, arg: primval\n) : primval // end of [primval_castfn]\n\n(* ****** ****** *)\n\nfun primval_selcon\n(\n  loc: location\n, hse: hisexp, pmv: primval, hse_sum: hisexp, lab: label\n) : primval // end of [primval_selcon]\nfun primval_select\n(\n  loc: location\n, hse: hisexp, pmv: primval, hse_rt: hisexp, pml: primlab\n) : primval // end of [primval_select]\nfun primval_select2\n(\n  loc: location\n, hse: hisexp, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : primval // end of [primval_select2]\n\n(* ****** ****** *)\n\nfun primval_selptr\n(\n  loc: location\n, hse: hisexp, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : primval // end of [primval_selptr]\n\n(* ****** ****** *)\n\nfun primval_ptrof\n  (loc: location, hse: hisexp, pmv: primval): primval\n// end of [primval_ptrof]\n\nfun primval_ptrofsel (\n  loc: location\n, hse: hisexp, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : primval // end of [primval_ptrofsel]\n\n(* ****** ****** *)\n\nfun primval_refarg\n(\n  loc: location\n, hse: hisexp, knd: int, freeknd: int, pmv: primval\n) : primval // end of [primval_refarg]\n\n(* ****** ****** *)\n//\nfun primval_funlab\n  (loc: location, hse: hisexp, flab: funlab): primval\nfun primval_cfunlab\n  (loc: location, hse: hisexp, knd: int, flab: funlab): primval\n//\n(* ****** ****** *)\n\nfun primval_d2vfunlab\n(\n  loc: location, hse: hisexp, d2v: d2var, flab: funlab\n) : primval // end of [primval_d2vfunlab]\n\n(* ****** ****** *)\n\nfun primval_lamfix (knd: int, pmv_funval: primval): primval\n\n(* ****** ****** *)\n\nfun primval_tmpltcst\n(\n  loc: location, hse: hisexp, d2c: d2cst, t2mas: t2mpmarglst\n) : primval // end of [primval_tmpltcst]\n\nfun primval_tmpltcstmat\n(\n  loc: location, hse: hisexp, d2c: d2cst, t2mas: t2mpmarglst, mat: tmpcstmat\n) : primval // end of [primval_tmpltcstmat]\n\n(* ****** ****** *)\n\nfun primval_tmpltvar\n(\n  loc: location, hse: hisexp, d2v: d2var, t2mas: t2mpmarglst\n) : primval // end of [primval_tmpltvar]\n\nfun primval_tmpltvarmat\n(\n  loc: location, hse: hisexp, d2v: d2var, t2mas: t2mpmarglst, mat: tmpvarmat\n) : primval // end of [primval_tmpltvarmat]\n\n(* ****** ****** *)\n\nfun primval_err (loc: location, hse: hisexp): primval\n\n(* ****** ****** *)\n\nfun primval_make_sizeof (loc: location, hselt: hisexp): primval\n\n(* ****** ****** *)\n\nfun primval_make_funlab\n  (loc: location, flab: funlab): primval\nfun primval_make2_funlab\n  (loc: location, hse0: hisexp, flab: funlab): primval\n\n(* ****** ****** *)\n\nfun primval_make_d2vfunlab\n  (loc: location, d2v: d2var, flab: funlab): primval\n// end of [primval_make_d2vfunlab]\n\n(* ****** ****** *)\n\nfun primval_make_tmp (loc: location, tmp: tmpvar): primval\nfun primval_make_tmpref (loc: location, tmp: tmpvar): primval\n\n(* ****** ****** *)\n\nfun primval_make_ptrofsel\n  (loc: location, pmv: primval, hse_rt: hisexp, pmls: primlablst): primval\n// end of [primval_make_ptrofsel]\n\n(* ****** ****** *)\n\nfun primlab_lab (loc: location, lab: label): primlab\nfun primlab_ind (loc: location, ind: primvalist): primlab\n\n(* ****** ****** *)\n\ndatatype patck =\n//\n  | PATCKcon of (d2con)\n//\n  | PATCKint of (int)\n  | PATCKbool of (bool)\n  | PATCKchar of (char)\n  | PATCKfloat of (double)\n  | PATCKstring of (string)\n//\n  | PATCKi0nt of (i0nt)\n  | PATCKf0loat of (f0loat)\n//\n// end of [patck]\n\n(* ****** ****** *)\n\ndatatype\ntmprimval =\n  | TPMVnone of (primval)\n  | TPMVsome of (tmpvar, primval)\n// end of [tmprimval]\n\n(* ****** ****** *)\n\nfun fprint_tmprimval\n  (out: FILEref, x: tmprimval): void\noverload fprint with fprint_tmprimval\n\n(* ****** ****** *)\n\ntypedef\ntmpmov = @(\n  tmprimval(*src*), tmpvar(*dst*)\n) (* end of [tmpmov] *)\n\ntypedef tmpmovlst = List (tmpmov)\nvtypedef tmpmovlst_vt = List_vt (tmpmov)\n\n(* ****** ****** *)\n\nfun fprint_tmpmovlst\n  (out: FILEref, xs: tmpmovlst): void\noverload fprint with fprint_tmpmovlst\n\n(* ****** ****** *)\n\ndatatype patckont =\n  | PTCKNTnone of ()\n  | PTCKNTtmplab of tmplab\n  | PTCKNTtmplabint of (tmplab, int)\n  | PTCKNTtmplabmov of (tmplab, tmpmovlst)\n  | PTCKNTcaseof_fail of (location) // run-time failure\n  | PTCKNTfunarg_fail of (location, funlab) // run-time failure\n  | PTCKNTraise of (tmpvar(*ret*), primval)\n// end of [patckont]\n\n(* ****** ****** *)\n\nfun print_patck (x: patck): void\noverload print with print_patck\nfun prerr_patck (x: patck): void\noverload prerr with prerr_patck\nfun fprint_patck : fprint_type (patck)\n\nfun print_patckont (x: patckont): void\noverload print with print_patckont\nfun prerr_patckont (x: patckont): void\noverload prerr with prerr_patckont\nfun fprint_patckont : fprint_type (patckont)\n\n(* ****** ****** *)\n\nfun patckont_is_none (fail: patckont): bool\n\n(* ****** ****** *)\n\ndatatype\ninstr_node =\n//\n  | INSfunlab of (funlab)\n  | INStmplab of (tmplab)\n//\n  | INScomment of (string)\n//\n  | INSmove_val of (tmpvar, primval)\n//\n  | INSpmove_val of (tmpvar(*ptr*), primval)\n//\n  | INSmove_arg_val of (int(*arg*), primval)\n//\n  | INSfcall of // regular funcall\n	  (tmpvar, primval(*fun*), hisexp, primvalist(*arg*))\n  | INSfcall2 of // tail-recursive funcall // ntl: 0/1+ : fun/fnx\n	  (tmpvar, funlab, int(*ntl*), hisexp, primvalist(*arg*))\n  | INSextfcall of (tmpvar, string(*fun*), primvalist(*arg*))\n//    \n  | INScond of ( // conditinal instruction\n	  primval(*test*), instrlst(*then*), instrlst(*else*)\n	) // end of [INScond]\n//\n  | INSfreecon of (primval) // memory deallocation\n//\n  | INSloop of (\n	  tmplab(*init*)\n	, tmplab(*fini*)\n	, tmplab(*cont*)\n	, instrlst(*init*)\n	, primval(*test*), instrlst(*test*)\n	, instrlst(*post*)\n	, instrlst(*body*)\n	) // end of [INSloop]\n  | INSloopexn of\n	  (int(*knd*), tmplab) // knd=0/1: break/continue\n//\n  | INScaseof of (ibranchlst) // caseof-branch-statements\n//\n  | INSletpop of ()\n  | INSletpush of (primdeclst)\n//\n  | INSmove_con of\n	  (tmpvar, d2con, hisexp, labprimvalist(*arg*))\n//\n  | INSmove_ref of (tmpvar, primval) // tmp := ref (pmv)\n//\n  | INSmove_boxrec of\n	  (tmpvar, labprimvalist(*arg*), hisexp)\n  | INSmove_fltrec of\n	  (tmpvar, labprimvalist(*arg*), hisexp)\n//\n  | INSpatck of (primval, patck, patckont) // pattern check\n//\n(*\n  | INSmove_selcon of\n	  (tmpvar, primval, hisexp(*tysum*), label)\n	// end of [INSmove_selcon]\n  | INSmove_select of\n	  (tmpvar, primval, hisexp(*tyroot*), primlab)\n	// end of [INSmove_select]\n  | INSmove_select2 of\n	  (tmpvar, primval, hisexp(*tyroot*), primlablst)\n	// end of [INSmove_select2]\n*)\n//\n  | INSmove_ptrofsel of\n	  (tmpvar, primval, hisexp(*tyroot*), primlablst)\n	// end of [INSmove_ptrofsel]\n//\n  | INSstore_ptrofs of\n	  (primval(*left*), hisexp(*tyroot*), primlablst(*ofs*), primval(*right*))\n  | INSxstore_ptrofs of\n	  (tmpvar, primval(*left*), hisexp(*tyroot*), primlablst(*ofs*), primval(*right*))\n//\n  | INSraise of (tmpvar(*dummy*), primval) // raising an exception\n//\n  | INSmove_delay of\n	  (tmpvar, int(*lin*), hisexp, primval(*thunk*)) // suspending evaluation\n  | INSmove_lazyeval of\n	  (tmpvar, int(*lin*), hisexp, primval(*lazyval*)) // evaluating lazy-values\n//\n  | INStrywith of (tmpvar(*exn*), instrlst, ibranchlst) // for try-with expressions\n//\n  | INSmove_list_nil of (tmpvar)\n  | INSpmove_list_nil of (tmpvar)\n  | INSpmove_list_cons of (tmpvar, hisexp(*elt*))\n  | INSmove_list_phead of // hd <- &(tl->val)\n	  (tmpvar(*hd*), tmpvar(*tl*), hisexp(*elt*))\n  | INSmove_list_ptail of // tl_new <- &(tl_old->next)\n	  (tmpvar(*new*), tmpvar(*old*), hisexp(*elt*))\n//\n  | INSmove_arrpsz_ptr of (tmpvar, tmpvar)\n//\n  | INSstore_arrpsz_asz of (tmpvar, int(*asz*))\n  | INSstore_arrpsz_ptr of (tmpvar, hisexp(*elt*), int(*asz*))\n//\n  | INSupdate_ptrinc of (tmpvar, hisexp(*elt*))\n  | INSupdate_ptrdec of (tmpvar, hisexp(*elt*))\n//\n  | INSclosure_initize of (tmpvar, funlab)\n//\n  | INStmpdec of (tmpvar) // HX-2013-01: this is a no-op\n//\n  | INSdcstdef of (d2cst, primval) // HX-2013-05: global const def\n//\n// end of [instr_node]\n\nwhere\ninstr = \'{\n  instr_loc= location, instr_node= instr_node\n} // end of [instr]\n\nand instrlst = List (instr)\nand instrlst_vt = List_vt (instr)\nand instrlstopt = Option (instrlst)\n\nand ibranch = \'{\n  ibranch_loc= location, ibranch_inslst= instrlst\n} // end of [ibranch]\n\nand ibranchlst = List (ibranch)\n\n(* ****** ****** *)\n\nfun print_instr (x: instr): void\nfun prerr_instr (x: instr): void\noverload prerr with prerr_instr\noverload print with print_instr\nfun fprint_instr : fprint_type (instr)\noverload fprint with fprint_instr\n\nfun fprint_instrlst : fprint_type (instrlst)\noverload fprint with fprint_instrlst\n\n(* ****** ****** *)\n\nfun instr_funlab (loc: location, flab: funlab): instr\nfun instr_tmplab (loc: location, tlab: tmplab): instr\n\n(* ****** ****** *)\n\nfun instr_comment (loc: location, str: string): instr\n\n(* ****** ****** *)\n\nfun instr_move_val\n(\n  loc: location, tmp: tmpvar, pmv: primval\n) : instr // end of [instr_move_val]\n\nfun instr_pmove_val\n(\n  loc: location, tmp: tmpvar, pmv: primval\n) : instr // end of [instr_pmove_val]\n\n(* ****** ****** *)\n\nfun instr_move_arg_val\n  (loc: location, arg: int, pmv: primval): instr\n// end of [instr_move_arg_val]\n\n(* ****** ****** *)\n\nfun instr_fcall\n(\n  loc: location\n, tmpret: tmpvar\n, pmv_fun: primval, hse_fun: hisexp, pmvs_arg: primvalist\n) : instr // end of [instr_fcall]\n\nfun instr_fcall2\n(\n  loc: location\n, tmpret: tmpvar\n, fl: funlab, ntl: int, hse_fun: hisexp\n, pmvs_arg: primvalist\n) : instr // end of [instr_fcall2]\n\nfun instr_extfcall\n(\n  loc: location\n, tmpret: tmpvar, _fun: string, _arg: primvalist\n) : instr // end of [instr_extfcall]\n\n(* ****** ****** *)\n\nfun instr_cond\n(\n  loc: location\n, _cond: primval, _then: instrlst, _else: instrlst\n) : instr // end of [instr_cond]\n\n(* ****** ****** *)\n\nfun instr_freecon (loc: location, pmv: primval): instr\n\n(* ****** ****** *)\n\nfun instr_loop\n(\n  loc: location\n, tlab_init: tmplab\n, tlab_fini: tmplab\n, tlab_cont: tmplab\n, inss_init: instrlst\n, pmv_test: primval, inss_test: instrlst\n, inss_post: instrlst\n, inss_body: instrlst\n) : instr // end of [instr_loop]\n\nfun instr_loopexn\n(\n  loc: location, knd: int, tlab: tmplab\n) : instr // end of [instr_loopexn]\n\n(* ****** ****** *)\n\nfun instr_caseof (loc: location, xs: ibranchlst): instr\n\n(* ****** ****** *)\n\nfun instr_letpop (loc: location): instr\nfun instr_letpush (loc: location, pmds: primdeclst): instr\n\n(* ****** ****** *)\n\nfun instr_move_con (\n  loc: location\n, tmp: tmpvar, d2c: d2con, hse_sum: hisexp, lpmvs: labprimvalist\n) : instr // end of [instr_move_con]\n\n(* ****** ****** *)\n\nfun instr_move_ref\n  (loc: location, tmp: tmpvar, pmv: primval): instr\n// end of [instr_move_ref]\n\n(* ****** ****** *)\n\nfun instr_move_boxrec\n(\n  loc: location, tmp: tmpvar, arg: labprimvalist, hse: hisexp\n) : instr // end of [instr_move_boxrec]\nfun instr_move_fltrec\n(\n  loc: location, tmp: tmpvar, arg: labprimvalist, hse: hisexp\n) : instr // end of [instr_move_fltrec]\nfun instr_move_fltrec2\n(\n  loc: location, tmp: tmpvar, arg: labprimvalist, hse: hisexp\n) : instr // end of [instr_move_fltrec2]\n\n(* ****** ****** *)\n\nfun instr_patck\n(\n  loc: location, pmv: primval, ptck: patck, ptknt: patckont\n) : instr // pattern check\n  \n(* ****** ****** *)\n\nfun instr_move_selcon (\n  loc: location\n, tmp: tmpvar, hse: hisexp, pmv: primval, hse_sum: hisexp, lab: label\n) : instr // end of [instr_move_selcon]\nfun instr_move_select (\n  loc: location\n, tmp: tmpvar, hse: hisexp, pmv: primval, hse_rt: hisexp, pml: primlab\n) : instr // end of [instr_move_select]\nfun instr_move_select2 (\n  loc: location\n, tmp: tmpvar, hse: hisexp, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : instr // end of [instr_move_select2]\n\n(* ****** ****** *)\n\nfun instr_move_ptrofsel\n(\n  loc: location, tmp: tmpvar\n, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : instr // end of [instr_move_ptrofsel]\n\n(* ****** ****** *)\n\n(*\nfun instr_load_ptrofs\n(\n  loc: location, tmp: tmpvar\n, pmv: primval, hse_rt: hisexp, pmls: primlablst\n) : instr // end of [instr_load_ptrofs]\n*)\n\n(* ****** ****** *)\n\nfun instr_store_ptrofs\n(\n  loc: location\n, pmv_l: primval, hse_rt: hisexp, pmls: primlablst\n, pmv_r: primval\n) : instr // end of [instr_store_ptrofs]\n\nfun instr_xstore_ptrofs\n(\n  loc: location, tmp: tmpvar\n, pmv_l: primval, hse_rt: hisexp, pmls: primlablst\n, pmv_r: primval\n) : instr // end of [instr_xstore_ptrofs]\n\n(* ****** ****** *)\n\nfun instr_raise\n(\n  loc: location, tmp: tmpvar, pmv_exn: primval\n) : instr // end of [instr_raise]\n\n(* ****** ****** *)\n\nfun instr_move_delay\n(\n  loc: location, tmp: tmpvar, lin: int, hse: hisexp, thunk: primval\n) : instr // end of [instr_move_delay]\n\nfun instr_move_lazyeval\n(\n  loc: location, tmp: tmpvar, lin: int, hse: hisexp, pmv_lazy: primval\n) : instr // end of [instr_move_lazyeval]\n\n(* ****** ****** *)\n\nfun instr_trywith\n(\n  loc: location\n, tmp(*exn*): tmpvar, _try: instrlst, _with: ibranchlst\n) : instr // end of [instr_trywith]\n\n(* ****** ****** *)\n\nfun instr_move_list_nil\n  (loc: location, tmp: tmpvar): instr\nfun instr_pmove_list_nil\n  (loc: location, tmp: tmpvar): instr\nfun instr_pmove_list_cons\n  (loc: location, tmp: tmpvar, elt: hisexp): instr\n\n(* ****** ****** *)\n\nfun instr_move_list_phead\n  (loc: location, tmphd: tmpvar, tmptl: tmpvar, elt: hisexp): instr\nfun instr_move_list_ptail\n  (loc: location, tl_new: tmpvar, tl_old: tmpvar, elt: hisexp): instr\n\n(* ****** ****** *)\n\nfun instr_move_arrpsz_ptr\n  (loc: location, tmp: tmpvar, psz: tmpvar): instr\n\n(* ****** ****** *)\n\nfun instr_store_arrpsz_asz\n  (loc: location, tmp: tmpvar, asz: int) : instr\nfun instr_store_arrpsz_ptr (\n  loc: location, tmp: tmpvar, hse_elt: hisexp, asz: int\n) : instr // end of [instr_store_arrpsz_asz]\n\n(* ****** ****** *)\n\nfun instr_update_ptrinc\n  (loc: location, tmpelt: tmpvar, hse_elt: hisexp): instr\n// end of [instr_update_ptrinc]\nfun instr_update_ptrdec\n  (loc: location, tmpelt: tmpvar, hse_elt: hisexp): instr\n// end of [instr_update_ptrdec]\n\n(* ****** ****** *)\n//\nfun instr_closure_initize\n  (loc: location, tmpret: tmpvar, flab: funlab): instr\n//\n(* ****** ****** *)\n\nfun instr_tmpdec (loc: location, tmp: tmpvar): instr\n\n(* ****** ****** *)\n\nfun instr_dcstdef (loc: location, d2c: d2cst, pmv: primval): instr\n\n(* ****** ****** *)\n\nfun ibranch_make (loc: location, inss: instrlst): ibranch\n\n(* ****** ****** *)\n\nfun primlab_lab (loc: location, lab: label): primlab\nfun primlab_ind (loc: location, ind: primvalist): primlab\n\n(* ****** ****** *)\n\nfun instrlst_get_tmpvarset (xs: instrlst): tmpvarset_vt\nfun primdeclst_get_tmpvarset (xs: primdeclst): tmpvarset_vt\n\n(* ****** ****** *)\n\nabsvtype instrseq_vtype\nvtypedef instrseq = instrseq_vtype\n\n(* ****** ****** *)\n\nfun instrseq_make_nil (): instrseq\nfun instrseq_get_free (res: instrseq): instrlst\n\n(* ****** ****** *)\n//\nfun instrseq_add (res: !instrseq, x: instr): void\n//\n(* ****** ****** *)\n//\nfun instrseq_add_comment (res: !instrseq, comment: string): void\n//\n(* ****** ****** *)\n//\nfun instrseq_add_tmpdec\n  (res: !instrseq, loc: location, tmp: tmpvar): void\nfun instrseq_add_dcstdef\n  (res: !instrseq, loc: location, d2c: d2cst, pmv: primval): void\n//\n(* ****** ****** *)\n//\nfun instrseq_addlst (res: !instrseq, xs: instrlst): void\nfun instrseq_addlst_vt (res: !instrseq, xs: instrlst_vt): void\n//\n(* ****** ****** *)\n//\nfun instrseq_add_freeconlst\n  (res: !instrseq, loc0: location, pmvs: primvalist_vt): void\n//\n(* ****** ****** *)\n\nfun hifundec_get_funlabopt (hfd: hifundec): Option (funlab)\nfun hifundec_set_funlabopt (hfd: hifundec, opt: Option (funlab)): void\n\n(* ****** ****** *)\n\nfun hiimpdec_get_funlabopt (imp: hiimpdec): Option (funlab)\nfun hiimpdec_set_funlabopt (imp: hiimpdec, opt: Option (funlab)): void\n\n(* ****** ****** *)\n\nfun hiimpdec_get_instrlstopt\n  (imp: hiimpdec): Option (instrlst)\nfun hiimpdec_set_instrlstopt\n  (imp: hiimpdec, opt: Option (instrlst)): void\n\n(* ****** ****** *)\n\ntypedef\nvbindmap = d2varmap (primval)\n\n(* ****** ****** *)\n\nfun fprint_vbindmap (out: FILEref, vbmap: vbindmap): void\n\n(* ****** ****** *)\n\nfun funent_make\n(\n  loc: location\n, flab: funlab\n, imparg: s2varlst\n, tmparg: s2explstlst\n, tmpsub: tmpsubopt\n, tmpret: tmpvar\n, fls0: funlablst, d2es: d2envlst\n, vbmap: vbindmap\n, inss_body: instrlst\n, tmplst: tmpvarlst\n) : funent // end of [funent_make]\n\nfun funent_make2\n(\n  loc: location\n, flab: funlab\n, imparg: s2varlst\n, tmparg: s2explstlst\n, tmpret: tmpvar\n, fls0: funlablst, d2es: d2envlst\n, vbmap: vbindmap\n, inss_body: instrlst\n) : funent // end of [funent_make2]\n\n(* ****** ****** *)\n\nfun funent_get_tmpsub (fent: funent): tmpsubopt\nfun funent_set_tmpsub\n  (fent: funent, opt: tmpsubopt): void = "patsopt_funent_set_tmpsub"\n// end of [funent_set_tmpsub]\n\nfun funent_get_vbindmap (fent: funent): vbindmap\n\nfun funent_get_instrlst (fent: funent): instrlst\n\n(* ****** ****** *)\n//\ndatatype\nhiimpdec2 =\nHIIMPDEC2 of (hiimpdec, tmpsub, s2explstlst)\n//\nfun fprint_hiimpdec2 (out: FILEref, imp2: hiimpdec2): void\n//\n(* ****** ****** *)\n\nabsvtype ccompenv_vtype\nvtypedef ccompenv = ccompenv_vtype\n\nfun ccompenv_make (): ccompenv\nfun ccompenv_free (env: ccompenv): void\n\n(* ****** ****** *)\n\nfun fprint_ccompenv (out: FILEref, env: !ccompenv): void\n\n(* ****** ****** *)\n\nfun ccompenv_get_tmplevel (env: !ccompenv): int\nfun ccompenv_inc_tmplevel (env: !ccompenv): void\nfun ccompenv_dec_tmplevel (env: !ccompenv): void\n\n(* ****** ****** *)\n\nfun ccompenv_get_tmprecdepth (env: !ccompenv): int\nfun ccompenv_inc_tmprecdepth (env: !ccompenv): void\nfun ccompenv_dec_tmprecdepth (env: !ccompenv): void\n\n(* ****** ****** *)\n//\nfun ccompenv_inc_freeconenv (env: !ccompenv): void\nfun ccompenv_getdec_freeconenv (env: !ccompenv): primvalist_vt\n//\nfun ccompenv_add_freeconenv\n  (env: !ccompenv, pmv: primval): void\nfun ccompenv_add_freeconenv_if\n  (env: !ccompenv, pmv: primval, pck: pckind, d2c: d2con): void\n//\n(* ****** ****** *)\n\nfun ccompenv_get_loopfini (env: !ccompenv): tmplab\nfun ccompenv_get_loopcont (env: !ccompenv): tmplab\n\nfun ccompenv_inc_loopexnenv\n(\n  env: !ccompenv, init: tmplab, fini: tmplab, cont: tmplab\n) : void // end of [ccompenv_inc_loopexnenv]\n\nfun ccompenv_dec_loopexnenv (env: !ccompenv): void\n\n(* ****** ****** *)\n//\nfun ccompenv_dec_tailcalenv (env: !ccompenv): void\n//\nfun ccompenv_inc_tailcalenv (env: !ccompenv, fl: funlab): void\nfun ccompenv_inc_tailcalenv_fnx (env: !ccompenv, fls: funlablst_vt): void\n//\nfun ccompenv_find_tailcalenv (env: !ccompenv, fl: funlab): int\n//\nfun ccompenv_find_tailcalenv_cst\n  (env: !ccompenv, d2c: d2cst): funlabopt_vt\nfun ccompenv_find_tailcalenv_tmpcst\n  (env: !ccompenv, d2c: d2cst, t2mas: t2mpmarglst): funlabopt_vt\n//\n(* ****** ****** *)\n\n(*\nfun ccompenv_get_funlevel (env: !ccompenv): int (* function level *)\n*)\n\n(* ****** ****** *)\n//\nfun ccompenv_inc_dvarsetenv (env: !ccompenv): void\nfun ccompenv_incwth_dvarsetenv (env: !ccompenv, d2es: d2envlst): void\nfun ccompenv_getdec_dvarsetenv (env: !ccompenv): d2envset_vt\n//\nfun ccompenv_add_dvarsetenv_var (env: !ccompenv, d2v: d2var): void\nfun ccompenv_add_dvarsetenv_env (env: !ccompenv, d2e: d2env): void\n//\n(* ****** ****** *)\n//\nfun ccompenv_inc_flabsetenv (env: !ccompenv): void\nfun ccompenv_getdec_flabsetenv (env: !ccompenv): funlabset_vt\nfun ccompenv_add_flabsetenv (env: !ccompenv, fl: funlab): void\n//\n(* ****** ****** *)\n//\nfun ccompenv_addlst_dvarsetenv_if\n  (env: !ccompenv, flev0: int, d2es: d2envlst): void\nfun ccompenv_addlst_flabsetenv_ifmap\n  (env: !ccompenv, flev0: int, vbmap: vbindmap, fls0: funlablst_vt): funlablst_vt\n//\n(* ****** ****** *)\n//\nfun ccompenv_inc_vbindmapenv (env: !ccompenv): void\nfun ccompenv_getdec_vbindmapenv (env: !ccompenv): vbindmap\n//\nfun ccompenv_add_vbindmapenv (env: !ccompenv, d2v: d2var, pmv: primval): void\nfun ccompenv_find_vbindmapenv (env: !ccompenv, d2v: d2var): Option_vt (primval)\n//\n(* ****** ****** *)\n\nabsview ccompenv_push_v\n\nfun ccompenv_push\n  (env: !ccompenv): (ccompenv_push_v | void)\n\nfun ccompenv_pop\n  (pfpush: ccompenv_push_v | env: !ccompenv): void\n\nfun ccompenv_localjoin\n  (pf1: ccompenv_push_v, pf2: ccompenv_push_v | env: !ccompenv): void\n\n(* ****** ****** *)\n\nfun ccompenv_add_vbindmapall\n  (env: !ccompenv, d2v: d2var, pmv: primval): void\n// end of [ccompenv_add_vbindmapall]\n  \nfun ccompenv_find_vbindmapall\n  (env: !ccompenv, d2v: d2var): Option_vt (primval)\n// end of [ccompenv_find_vbindmapall]\n\n(* ****** ****** *)\n\nfun ccompenv_add_vbindmapenvall\n  (env: !ccompenv, d2v: d2var, pmv: primval): void\n// end of [ccompenv_add_vbindmapenvall]\n\n(* ****** ****** *)\n//\nfun ccompenv_add_fundec (env: !ccompenv, hfd: hifundec): void\n//\nfun ccompenv_add_impdec (env: !ccompenv, imp: hiimpdec): void\nfun ccompenv_add_impdec2 (env: !ccompenv, imp2: hiimpdec2): void\n//\nfun ccompenv_add_staload (env: !ccompenv, fenv: filenv): void\n//\n(* ****** ****** *)\n//\nfun ccompenv_add_tmpsub (env: !ccompenv, tsub: tmpsub): void\n//\nfun ccompenv_add_impdecloc (env: !ccompenv, imp: hiimpdec): void\n//\nfun ccompenv_add_fundecsloc\n(\n  env: !ccompenv, knd: funkind, decarg: s2qualst, hfds: hifundeclst\n) : void // end of [ccompenv_add_fundecsloc]\n//\nfun ccompenv_add_tmpcstmat (env: !ccompenv, tmpmat: tmpcstmat): void\nfun ccompenv_add_tmpvarmat (env: !ccompenv, tmpmat: tmpvarmat): void\n//\n(* ****** ****** *)\n\nfun ccompenv_get_d2vbindmap (env: !ccompenv): d2varmap (primval)\n\n(* ****** ****** *)\n\nfun hipatck_ccomp\n(\n  env: !ccompenv, res: !instrseq\n, fail: patckont, hip: hipat, pmv: primval\n) : void // end of [hipatck_ccomp]\n\n(* ****** ****** *)\n\nfun himatch_ccomp\n(\n  env: !ccompenv, res: !instrseq\n, level: int, hip: hipat, pmv: primval // HX: [pmv] matches [hip]\n) : void // end of [himatch_ccomp]\n\nfun himatch2_ccomp\n(\n  env: !ccompenv, res: !instrseq\n, level: int, hip: hipat, pmv: primval // HX: [pmv] matches [hip]\n) : void // end of [himatch2_ccomp]\n\n(* ****** ****** *)\n\nfun hifunarg_ccomp\n(\n  env: !ccompenv, res: !instrseq\n, flab: funlab, level: int, loc_fun: location, hips: hipatlst\n) : void // end of [hifunarg_ccomp]\n\n(* ****** ****** *)\n\ntypedef\nhidexp_ccomp_funtype =\n  (!ccompenv, !instrseq, hidexp) -> primval\n//\nfun hidexp_ccomp : hidexp_ccomp_funtype\nfun hidexp_ccomp_lam : hidexp_ccomp_funtype\nfun hidexp_ccomp_fix : hidexp_ccomp_funtype\nfun hidexp_ccomp_loop : hidexp_ccomp_funtype\nfun hidexp_ccomp_loopexn : hidexp_ccomp_funtype\n//\nfun hidexp_ccompv : hidexp_ccomp_funtype  \n//\n(* ****** ****** *)\n\ntypedef\nhidexp_ccomp_ret_funtype =\n  (!ccompenv, !instrseq, tmpvar(*ret*), hidexp) -> void\n//\nfun hidexp_ccomp_ret : hidexp_ccomp_ret_funtype\n//\nfun hidexp_ccomp_ret_case : hidexp_ccomp_ret_funtype\n//\nfun hidexp_ccomp_ret_raise : hidexp_ccomp_ret_funtype\n//\nfun hidexp_ccomp_ret_delay : hidexp_ccomp_ret_funtype\nfun hidexp_ccomp_ret_ldelay : hidexp_ccomp_ret_funtype\nfun hidexp_ccomp_ret_lazyeval : hidexp_ccomp_ret_funtype\n//\nfun hidexp_ccomp_ret_trywith : hidexp_ccomp_ret_funtype\n//\n(* ****** ****** *)\n\nfun hidexplst_ccomp\n  (env: !ccompenv, res: !instrseq, hdes: hidexplst): primvalist\n// end of [hidexplst_ccomp]\n\n(* ****** ****** *)\n\nfun hidexp_ccomp_funlab_arg_body\n(\n  env: !ccompenv\n, flab: funlab // HX: needed for recursion\n, imparg: s2varlst\n, tmparg: s2explstlst\n, prolog: instrlst\n, loc_fun: location\n, hips_arg: hipatlst\n, hde_body: hidexp\n) : funent // end of [hidexp_ccomp_arg_body_funlab]\n\n(* ****** ****** *)\n\nfun\nhiclaulst_ccomp\n(\n  env: !ccompenv\n, lvl0: int\n, pmvs: primvalist\n, hicls: hiclaulst\n, tmpret: tmpvar\n, fail: patckont\n) : ibranchlst // end of [hiclaulst_ccomp]\n\n(* ****** ****** *)\n\nfun hilab_ccomp\n  (env: !ccompenv, res: !instrseq, hil: hilab): primlab\nfun hilablst_ccomp\n  (env: !ccompenv, res: !instrseq, hils: hilablst): primlablst\n\n(* ****** ****** *)\n\nfun hiimpdec_ccomp\n(\n  env: !ccompenv, level: int, imp: hiimpdec\n) : void // end of [hiimpdec_ccomp]\n\nfun hiimpdec_ccomp_if\n(\n  env: !ccompenv, level: int, imp: hiimpdec\n) : void // end of [hiimpdec_ccomp_if]\n\n(* ****** ****** *)\n\nfun hifundeclst_ccomp\n(\n  env: !ccompenv, lvl0: int\n, knd: funkind, decarg: s2qualst, hfds: hifundeclst\n) : void // end of [hifundeclst_ccomp]\n\n(* ****** ****** *)\n\nfun hidecl_ccomp\n  (env: !ccompenv, hdc: hidecl): primdec\nfun hideclist_ccomp\n  (env: !ccompenv, hdcs: hideclist): primdeclst\n\nfun hideclist_ccomp0 (hdcs: hideclist): primdeclst\n\n(* ****** ****** *)\n//\n// HX-2013-04: for handling environvals\n//\nfun funent_varbindmap_initize (fent: funent): void\nfun funent_varbindmap_uninitize (fent: funent): void\nfun the_funent_varbindmap_find (d2v: d2var): Option_vt (primval)\n//\n(* ****** ****** *)\n\nfun emit_text\n  (out: FILEref, txt: string): void\n// end of [emit_text]\n\nfun emit_lparen (out: FILEref): void\nfun emit_rparen (out: FILEref): void\n\nfun emit_newline (out: FILEref): void\n\n(* ****** ****** *)\n\nfun emit_location (out: FILEref, x: location): void\n\n(* ****** ****** *)\n\nfun emit_int (out: FILEref, x: int): void\nfun emit_intinf (out: FILEref, x: intinf): void\nfun emit_bool (out: FILEref, x: bool): void\nfun emit_char (out: FILEref, x: char): void\nfun emit_float (out: FILEref, x: double): void\nfun emit_string (out: FILEref, x: string): void\n\n(* ****** ****** *)\n\nfun emit_ATSPMVint (out: FILEref, x: int): void\nfun emit_ATSPMVintrep (out: FILEref, x: string): void\n\nfun emit_ATSPMVbool (out: FILEref, x: bool): void\nfun emit_ATSPMVchar (out: FILEref, x: char): void\nfun emit_ATSPMVfloat (out: FILEref, x: double): void\nfun emit_ATSPMVstring (out: FILEref, str: string): void\n\nfun emit_ATSPMVi0nt (out: FILEref, tok: $SYN.i0nt): void\nfun emit_ATSPMVf0loat (out: FILEref, tok: $SYN.f0loat): void\n\n(* ****** ****** *)\n\nfun emit_stamp (out: FILEref, x: stamp): void\nfun emit_symbol (out: FILEref, x: symbol): void\n\n(* ****** ****** *)\n\nfun emit_time_stamp (out: FILEref): void\nfun emit_ats_ccomp_header (out: FILEref): void\nfun emit_ats_ccomp_prelude (out: FILEref): void\n\n(* ****** ****** *)\n\nfun emit_ident (out: FILEref, id: string): void\n\nfun emit_label (out: FILEref, lab: label): void\nfun emit_atslabel (out: FILEref, lab: label): void\nfun emit_labelext (out: FILEref, knd: int, lab: label): void\n\nfun emit_filename (out: FILEref, fil: filename): void\n\n(* ****** ****** *)\n\nfun emit_primcstsp (out: FILEref, pmc: primcstsp): void\n\n(* ****** ****** *)\n\nfun emit_s2cst (out: FILEref, d2c: s2cst): void // HX: global\nfun emit2_s2cst (out: FILEref, d2c: s2cst): void // HX: local\n\n(* ****** ****** *)\n\nfun emit_d2con (out: FILEref, d2c: d2con): void\nfun emit_d2cst (out: FILEref, d2c: d2cst): void // HX: global\nfun emit2_d2cst (out: FILEref, d2c: d2cst): void // HX: local\n\n(* ****** ****** *)\n\nfun emit_d2env (out: FILEref, d2e: d2env): void\nfun emit_d2var_env (out: FILEref, d2v: d2var): void\nfun emit_d2envlst (out: FILEref, d2es: d2envlst, i: int): int(*nenv*)\n\n(* ****** ****** *)\n\nfun emit_exndec (out: FILEref, hid: hidecl): void\nfun emit_saspdec (out: FILEref, hid: hidecl): void\n\n(* ****** ****** *)\n\nfun emit_extype (out: FILEref, hid: hidecl): void\nfun emit_extcode (out: FILEref, hid: hidecl): void\n\n(* ****** ****** *)\n\nfun emit_staload (out: FILEref, hid: hidecl): void\nfun emit_dynload (out: FILEref, hid: hidecl): void\n\n(* ****** ****** *)\n//\nfun emit_d2con_extdec (out: FILEref, d2c: d2con): void\nfun emit_d2conlst_extdec (out: FILEref, d2cs: d2conlst): void\nfun emit_d2conlst_initize (out: FILEref, d2cs: d2conlst): void\n//\nfun emit_d2cst_extdec (out: FILEref, d2c: d2cst): void\nfun emit_d2cstlst_extdec (out: FILEref, d2cs: d2cstlst): void\n//\n(* ****** ****** *)\n\nfun emit_sizeof (out: FILEref, hselt: hisexp): void\n\n(* ****** ****** *)\n\nfun emit_tmplab (out: FILEref, tlab: tmplab): void\nfun emit_tmplabint (out: FILEref, tlab: tmplab, i: int): void\n\n(* ****** ****** *)\n\nfun emit_set_nfnx (n: int): void\nfun emit_funarg (out: FILEref, n: int): void\nfun emit_funargx (out: FILEref, n: int): void\n\n(* ****** ****** *)\n\nfun emit_tmpvar (out: FILEref, tmp: tmpvar): void\n\n(* ****** ****** *)\n\nfun emit_funlab (out: FILEref, flab: funlab): void // HX: global\nfun emit2_funlab (out: FILEref, flab: funlab): void // HX: local\n\n(* ****** ****** *)\n\nfun emit_tmpdec (out: FILEref, tmp: tmpvar): void\nfun emit_tmpdeclst (out: FILEref, tmps: tmpvarlst): void\n\n(* ****** ****** *)\n//\n// HX-2013-01:\n// these are implemented in [pats_ccomp_hitype.dats]\n//\nabstype hitype_type\ntypedef hitype = hitype_type\ntypedef hitypelst = List (hitype)\n\nfun print_hitype (hit: hitype): void\noverload print with print_hitype\nfun prerr_hitype (hit: hitype): void\noverload prerr with prerr_hitype\nfun fprint_hitype : fprint_type (hitype)\nfun fprint_hitypelst : fprint_type (hitypelst)\noverload fprint with fprint_hitype\noverload fprint with fprint_hitypelst\n\n(* ****** ****** *)\n//\n// HX: flag=0/1: flatten/regular\n//\nfun hisexp_typize (flag: int, hse: hisexp): hitype\n//\n(* ****** ****** *)\n\nfun emit_hitype (out: FILEref, hit: hitype): void\n\n(* ****** ****** *)\n\nfun emit_hisexp (out: FILEref, hse: hisexp): void\nfun emit_hisexplst_sep\n  (out: FILEref, hses: hisexplst, sep: string): void\n// end of [emit_hisexplst_sep]\n\nfun emit_hisexp_sel (out: FILEref, hse: hisexp): void\n\n(* ****** ****** *)\n\nfun emit_funtype_arg_res\n  (out: FILEref, _arg: hisexplst, _res: hisexp): void\n// end of [emit_funtype_arg_res]\n\n(* ****** ****** *)\n\nfun emit_primval (out: FILEref, pmv: primval): void\nfun emit_primvalist (out: FILEref, pmvs: primvalist): void\n\n(* ****** ****** *)\n\nfun emit_primval_deref\n  (out: FILEref, pmv: primval, hse_rt: hisexp): void\n// end of [emit_primval_deref]\n\n(* ****** ****** *)\n\nfun emit_primlab (out: FILEref, extknd: int, pml: primlab): void\n\n(* ****** ****** *)\n//\ntypedef\nemit_instr_type = (FILEref, instr) -> void\n//\nfun emit_instr : emit_instr_type\n//\nfun emit_instr_fcall : emit_instr_type\nfun emit_instr_fcall2 : emit_instr_type\nfun emit_instr_extfcall : emit_instr_type\n//\nfun emit_instr_patck : emit_instr_type\n//\n(* ****** ****** *)\n\nfun emit_ibranchlst : (FILEref, ibranchlst) -> void\n\n(* ****** ****** *)\n\nfun emit_instrlst (out: FILEref, inss: instrlst): void\nfun emit_instrlst_ln (out: FILEref, inss: instrlst): void\n\n(* ****** ****** *)\n//\nfun emit_funenvlst\n  (out: FILEref, d2es: d2envlst): int\nfun emit_funarglst\n  (out: FILEref, nenv: int, hses_arg: hisexplst): void\n//\n(* ****** ****** *)\n//\nfun emit_the_tmpdeclst (out: FILEref): void\nfun emit_the_funlablst (out: FILEref): void\nfun emit_the_primdeclst (out: FILEref): void\nfun emit_the_typedeflst (out: FILEref): void\n//\nfun emit_the_dynconlst_extdec (out: FILEref): void\nfun emit_the_dyncstlst_extdec (out: FILEref): void\n//\nfun emit_the_primdeclst_valimp (out: FILEref): void\n//\n(* ****** ****** *)\n//\n// HX: for emitting the prototype of a function entry\n//\nfun emit_funent_ptype (out: FILEref, fent: funent): void\n//\nfun emit_funent_closure (out: FILEref, fent: funent): void\n//\nfun emit_funent_implmnt (out: FILEref, fent: funent): void\n//\n(* ****** ****** *)\n\nfun emit_primdeclst (out: FILEref, pmds: primdeclst): void\n\n(* ****** ****** *)\n\nfun funlab_tmpcst_match\n  (fl: funlab, d2c: d2cst, t2mas: t2mpmarglst): bool\n// end of [funlab_tmpcst_match]\n\n(* ****** ****** *)\n\nfun hiimpdec_tmpcst_match\n  (imp: hiimpdec, d2c: d2cst, t2mas: t2mpmarglst): tmpcstmat\n// end of [hiimpdec_tmpcst_match]\n\nfun hiimpdeclst_tmpcst_match\n  (imps: hiimpdeclst, d2c: d2cst, t2mas: t2mpmarglst): tmpcstmat\n// end of [hiimpdeclst_tmpcst_match]\n\nfun hiimpdec2_tmpcst_match\n  (imp2: hiimpdec2, d2c: d2cst, t2mas: t2mpmarglst): tmpcstmat\n// end of [hiimpdec2_tmpcst_match]\n\n(* ****** ****** *)\n\nfun hifundec2tmpvarmat\n  (hfd: hifundec, t2mas: t2mpmarglst): tmpvarmat\nfun hifundecopt2tmpvarmat\n  (opt: Option_vt (hifundec), t2mas: t2mpmarglst): tmpvarmat\nfun hifundec_tmpvar_match\n  (hfd: hifundec, d2v: d2var, t2mas: t2mpmarglst): tmpvarmat\n// end of [hiimpdec_tmpvar_match]\n\n(* ****** ****** *)\n\nfun tmpcstmat_tmpcst_match\n  (mat: tmpcstmat, d2c: d2cst, t2mas: t2mpmarglst): tmpcstmat\n// end of [tmpcstmat_tmpcst_match]\n\nfun ccompenv_tmpcst_match\n  (env: !ccompenv, d2c: d2cst, t2mas: t2mpmarglst): tmpcstmat\n// end of [ccompenv_tmpcst_match]\n\nfun ccomp_tmpcstmat\n(\n  env: !ccompenv, loc0: location, hse0: hisexp\n, d2c: d2cst, t2ms: t2mpmarglst, tmpmat: tmpcstmat\n) : primval // end of [ccomp_tmpcstmat]\n\n(* ****** ****** *)\n\nfun tmpvarmat_tmpvar_match\n  (mat: tmpvarmat, d2v: d2var, t2mas: t2mpmarglst): tmpvarmat\n// end of [tmpvarmat_tmpvar_match]\n\nfun ccompenv_tmpvar_match\n  (env: !ccompenv, d2v: d2var, t2mas: t2mpmarglst): tmpvarmat\n// end of [ccompenv_tmpvar_match]\n\nfun ccomp_tmpvarmat\n(\n  env: !ccompenv, loc0: location, hse0: hisexp\n, d2v: d2var, t2ms: t2mpmarglst, tmpmat: tmpvarmat\n) : primval // end of [ccomp_tmpvarmat]\n\n(* ****** ****** *)\n\nfun t2mpmarglst_subst\n  (loc0: location, sub: !stasub, t2mas: t2mpmarglst): t2mpmarglst\n// end of [t2mpmarglst_subst]\n\nfun t2mpmarglst_tsubst\n  (loc0: location, tsub: tmpsub, t2mas: t2mpmarglst): t2mpmarglst\n// end of [t2mpmarglst_tsubst]\n\n(* ****** ****** *)\n//\nfun d2envlst_subst\n  (sub: !stasub, d2vs: d2envlst): d2envlst_vt\n//\n(* ****** ****** *)\n//\nfun funlab_subst\n  (sub: !stasub, flab: funlab): funlab\n//\nfun funent_subst\n(\n  env: !ccompenv\n, sub: !stasub, flab2: funlab, fent: funent, sfx: int\n) : funent // end of [funent_subst]\n\n(* ****** ****** *)\n\nfun the_toplevel_getref_tmpvarlst (): Ptr1\nfun the_toplevel_getref_primdeclst (): Ptr1\n\n(* ****** ****** *)\n\nfun ccomp_main\n(\n  out: FILEref, flag: int, infil: filename, hdcs: hideclist\n) : void // end of [ccomp_main]\n\n(* ****** ****** *)\n\n(* end of [pats_ccomp.sats] *)',b="int main () {\n}",{id:"aaa",filenames:["README","file1.sats","file2.c"],filecontents:[c,a,b]}
})}.call(this),function(){"use strict";angular.module("atsPadApp").controller("FiletoolbarCtrl",["$scope","appContextService","appFileService","appPadService","appUrlService",function(a,b,c,d,e){return a.add=function(){return a.pad.filenames.push(""),a.pad.filecontents.push(""),c.select(a.pad.filenames.length-1),c.edit(!0)},a.refresh=function(){return b.isReady()?d.syncToClient(function(b){return a.pad.filenames=b.filenames,a.pad.filecontents=b.filecontents}):void 0},a.isEditing=function(){return c.isEditing()},a.download=function(){return e.downloadLink()}}])}.call(this),function(){"use strict";angular.module("atsPadApp").controller("SidebarCtrl",["$scope","$timeout","$location","appTerminalService","appNotificationService","appContextService","appPadService","appFileService",function(a,b,c,d,e,f,g,h){var i,j,k;return k=e,a.flags={},a.newpad=function(){return k.debug("creating new pad"),f.reset(),b(function(){return c.path("/")})},a.forkpad=function(){var a;return k.debug("forking current pad"),a=f.getId(),b(function(){return c.path("/"+a+"/fork")})},a.deletepad=function(){return k.debug("deleting pad"),b(function(){return c.path("/")},1e3),g["delete"](function(){return k.success("Your pad has been deleted. Creating a new one ...")})},i=function(){var b,c;return c=function(){var c,d,e,f;for(e=a.pad.filenames,f=[],c=0,d=e.length;d>c;c++)b=e[c],/.*dats/i.test(b)&&f.push(b);return f}(),c.join(" ")},j=function(){var b;switch(b=a.pad.filenames[h.active()],!1){case!/.*dats/i.test(b):return"-d "+b;case!/.*sats/i.test(b):return"-s "+b;default:return null}},a.run=function(){var b,c;return k.debug("running"),0===function(){var c,d,e,f;for(e=a.pad.filenames,f=[],c=0,d=e.length;d>c;c++)b=e[c],/.*dats/i.test(b)&&f.push(b);return f}().length?d.msg("No files to run."):(c="",a.flags.ATS_MEMALLOC_LIBC&&(c+=" -DATS_MEMALLOC_LIBC"),d.cmd("patscc "+i()+" "+c),d.cmd("./a.out"))},a.typecheck=function(){return null==j()?d.msg("Can't type check current file: "+a.pad.filenames[h.active()]):d.cmd("patsopt -tc "+j())}}])}.call(this),function(){"use strict";angular.module("atsPadApp").controller("NavbarCtrl",["$scope","$location","appContextService",function(a,b,c){return a.$watch(function(){return c.getId()},function(a,b,c){return c.id=a}),a.isActive=function(a){return b.path()===a}}])}.call(this),function(){"use strict";angular.module("atsPadApp").controller("ForkCtrl",["$location","$timeout","$scope","appNotificationService","$routeParams","appTerminalService","appPadService","appContextService",function(a,b,c,d,e,f,g,h){var i;return i=d,null==e.id?i.error("no pad id present, can't fork"):(i.debug("pad id "+e.id+", forking"),h.reset(),g.fork(e.id,function(c){return b(function(){return a.path(c)})}))}])}.call(this),function(){"use strict";angular.module("atsPadApp").directive("appMarkdown",["appMarkdownService",function(a){return{restrict:"AE",link:function(b,c){return c.replaceWith(a.toHtml(c.html()))}}}])}.call(this);